{"ast":null,"code":"'use strict';\n\nconst waterfall = require('async/waterfall');\n\nconst CID = require('cids');\n\nconst util = require('./util');\n\nexports = module.exports;\nexports.multicodec = 'dag-pb';\nexports.defaultHashAlg = 'sha2-256';\n/*\r\n * resolve: receives a path and a binary blob and returns the value on path,\r\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\r\n */\n\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([cb => util.deserialize(binaryBlob, cb), (node, cb) => {\n    // Return the deserialized block if no path is given\n    if (!path) {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n\n    const split = path.split('/');\n\n    if (split[0] === 'Links') {\n      let remainderPath = ''; // all links\n\n      if (!split[1]) {\n        return cb(null, {\n          value: node.links.map(l => l.toJSON()),\n          remainderPath: ''\n        });\n      } // select one link\n\n\n      const values = {}; // populate both index number and name to enable both cases\n      // for the resolver\n\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[i] = values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      let value = values[split[1]]; // if remainderPath exists, value needs to be CID\n\n      if (split[2] === 'Hash') {\n        value = {\n          '/': value.hash\n        };\n      } else if (split[2] === 'Tsize') {\n        value = value.size;\n      } else if (split[2] === 'Name') {\n        value = value.name;\n      }\n\n      remainderPath = split.slice(3).join('/');\n      cb(null, {\n        value: value,\n        remainderPath: remainderPath\n      });\n    } else if (split[0] === 'Data') {\n      cb(null, {\n        value: node.data,\n        remainderPath: ''\n      });\n    } else {\n      // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n      // to a named link from the Links array. This is because go-ipfs and\n      // js-ipfs have historically supported the ability to do\n      // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n      const values = {};\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      const value = values[split[0]];\n\n      if (value) {\n        return cb(null, {\n          value: {\n            '/': value.hash\n          },\n          remainderPath: split.slice(1).join('/')\n        });\n      }\n\n      cb(new Error('path not available'));\n    }\n  }], callback);\n};\n/*\r\n * tree: returns a flattened array with paths: values of the project. options\r\n * is an object that can carry several options (i.e. nestness)\r\n */\n\n\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const paths = [];\n    paths.push('Links');\n    node.links.forEach((link, i) => {\n      paths.push(`Links/${i}/Name`);\n      paths.push(`Links/${i}/Tsize`);\n      paths.push(`Links/${i}/Hash`);\n    });\n    paths.push('Data');\n    callback(null, paths);\n  });\n};\n/*\r\n * isLink: returns the Link if a given path in a binary blob is a Link,\r\n * false otherwise\r\n */\n\n\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid;\n\n      try {\n        valid = CID.isCID(new CID(result.value['/']));\n      } catch (err) {\n        valid = false;\n      }\n\n      if (valid) {\n        return callback(null, result.value);\n      }\n    }\n\n    callback(null, false);\n  });\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/ipld-dag-pb/src/resolver.js"],"names":["waterfall","require","CID","util","exports","module","multicodec","defaultHashAlg","resolve","binaryBlob","path","callback","cb","deserialize","node","value","remainderPath","split","links","map","l","toJSON","values","forEach","i","link","name","hash","multihash","size","slice","join","data","Error","tree","options","err","paths","push","isLink","result","length","valid","isCID"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst waterfall = require('async/waterfall')\r\nconst CID = require('cids')\r\n\r\nconst util = require('./util')\r\n\r\nexports = module.exports\r\nexports.multicodec = 'dag-pb'\r\nexports.defaultHashAlg = 'sha2-256'\r\n\r\n/*\r\n * resolve: receives a path and a binary blob and returns the value on path,\r\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\r\n */\r\nexports.resolve = (binaryBlob, path, callback) => {\r\n  waterfall([\r\n    (cb) => util.deserialize(binaryBlob, cb),\r\n    (node, cb) => {\r\n      // Return the deserialized block if no path is given\r\n      if (!path) {\r\n        return callback(null, {\r\n          value: node,\r\n          remainderPath: ''\r\n        })\r\n      }\r\n\r\n      const split = path.split('/')\r\n\r\n      if (split[0] === 'Links') {\r\n        let remainderPath = ''\r\n\r\n        // all links\r\n        if (!split[1]) {\r\n          return cb(null, {\r\n            value: node.links.map((l) => l.toJSON()),\r\n            remainderPath: ''\r\n          })\r\n        }\r\n\r\n        // select one link\r\n\r\n        const values = {}\r\n\r\n        // populate both index number and name to enable both cases\r\n        // for the resolver\r\n        node.links.forEach((l, i) => {\r\n          const link = l.toJSON()\r\n          values[i] = values[link.name] = {\r\n            hash: link.multihash,\r\n            name: link.name,\r\n            size: link.size\r\n          }\r\n        })\r\n\r\n        let value = values[split[1]]\r\n\r\n        // if remainderPath exists, value needs to be CID\r\n        if (split[2] === 'Hash') {\r\n          value = { '/': value.hash }\r\n        } else if (split[2] === 'Tsize') {\r\n          value = value.size\r\n        } else if (split[2] === 'Name') {\r\n          value = value.name\r\n        }\r\n\r\n        remainderPath = split.slice(3).join('/')\r\n\r\n        cb(null, { value: value, remainderPath: remainderPath })\r\n      } else if (split[0] === 'Data') {\r\n        cb(null, { value: node.data, remainderPath: '' })\r\n      } else {\r\n        // If split[0] is not 'Data' or 'Links' then we might be trying to refer\r\n        // to a named link from the Links array. This is because go-ipfs and\r\n        // js-ipfs have historically supported the ability to do\r\n        // `ipfs dag get CID/a` where a is a named link in a dag-pb.\r\n        const values = {}\r\n\r\n        node.links.forEach((l, i) => {\r\n          const link = l.toJSON()\r\n          values[link.name] = {\r\n            hash: link.multihash,\r\n            name: link.name,\r\n            size: link.size\r\n          }\r\n        })\r\n\r\n        const value = values[split[0]]\r\n\r\n        if (value) {\r\n          return cb(null, {\r\n            value: { '/': value.hash },\r\n            remainderPath: split.slice(1).join('/')\r\n          })\r\n        }\r\n\r\n        cb(new Error('path not available'))\r\n      }\r\n    }\r\n  ], callback)\r\n}\r\n\r\n/*\r\n * tree: returns a flattened array with paths: values of the project. options\r\n * is an object that can carry several options (i.e. nestness)\r\n */\r\nexports.tree = (binaryBlob, options, callback) => {\r\n  if (typeof options === 'function') {\r\n    callback = options\r\n    options = {}\r\n  }\r\n\r\n  options = options || {}\r\n\r\n  util.deserialize(binaryBlob, (err, node) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    const paths = []\r\n\r\n    paths.push('Links')\r\n\r\n    node.links.forEach((link, i) => {\r\n      paths.push(`Links/${i}/Name`)\r\n      paths.push(`Links/${i}/Tsize`)\r\n      paths.push(`Links/${i}/Hash`)\r\n    })\r\n\r\n    paths.push('Data')\r\n\r\n    callback(null, paths)\r\n  })\r\n}\r\n\r\n/*\r\n * isLink: returns the Link if a given path in a binary blob is a Link,\r\n * false otherwise\r\n */\r\nexports.isLink = (binaryBlob, path, callback) => {\r\n  exports.resolve(binaryBlob, path, (err, result) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    if (result.remainderPath.length > 0) {\r\n      return callback(new Error('path out of scope'))\r\n    }\r\n\r\n    if (typeof result.value === 'object' && result.value['/']) {\r\n      let valid\r\n      try {\r\n        valid = CID.isCID(new CID(result.value['/']))\r\n      } catch (err) {\r\n        valid = false\r\n      }\r\n      if (valid) {\r\n        return callback(null, result.value)\r\n      }\r\n    }\r\n\r\n    callback(null, false)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}