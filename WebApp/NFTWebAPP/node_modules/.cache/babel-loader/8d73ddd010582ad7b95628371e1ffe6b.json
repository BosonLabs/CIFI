{"ast":null,"code":"'use strict';\n\nconst cbor = require('borc');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isCircular = require('is-circular');\n\nconst resolver = require('./resolver'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nconst CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nconst decoder = new cbor.Decoder({\n  tags: {\n    [CID_CBOR_TAG]: val => {\n      // remove that 0\n      val = val.slice(1);\n      return new CID(val);\n    }\n  }\n});\n\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    const keys = Object.keys(obj);\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n      return tagCID(obj['/']);\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nexports = module.exports;\n\nexports.serialize = (dagNode, callback) => {\n  let serialized;\n\n  try {\n    const dagNodeTagged = replaceCIDbyTAG(dagNode);\n    serialized = cbor.encode(dagNodeTagged);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n\n  setImmediate(() => callback(null, serialized));\n};\n\nexports.deserialize = (data, callback) => {\n  let deserialized;\n\n  try {\n    deserialized = decoder.decodeFirst(data);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n\n  setImmediate(() => callback(null, deserialized));\n};\n/**\r\n * @callback CidCallback\r\n * @param {?Error} error - Error if getting the CID failed\r\n * @param {?CID} cid - CID if call was successful\r\n */\n\n/**\r\n * Get the CID of the DAG-Node.\r\n *\r\n * @param {Object} dagNode - Internal representation\r\n * @param {Object} [options] - Options to create the CID\r\n * @param {number} [options.version=1] - CID version number\r\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\r\n * @param {number} [options.hashLen] - Optionally trim the digest to this length\r\n * @param {CidCallback} callback - Callback that handles the return value\r\n * @returns {void}\r\n */\n\n\nexports.cid = (dagNode, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  const hashLen = options.hashLen;\n  const version = typeof options.version === 'undefined' ? 1 : options.version;\n  exports.serialize(dagNode, (err, serialized) => {\n    if (err) return callback(err);\n    multihashing(serialized, hashAlg, hashLen, (err, mh) => {\n      if (err) return callback(err);\n      callback(null, new CID(version, resolver.multicodec, mh));\n    });\n  });\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/ipld-dag-cbor/src/util.js"],"names":["cbor","require","multihashing","CID","isCircular","resolver","CID_CBOR_TAG","tagCID","cid","buffer","isCID","Tagged","Buffer","concat","from","decoder","Decoder","tags","val","slice","replaceCIDbyTAG","dagNode","circular","e","Error","transform","obj","isBuffer","Array","isArray","map","keys","Object","length","out","forEach","key","exports","module","serialize","callback","serialized","dagNodeTagged","encode","err","setImmediate","deserialize","data","deserialized","decodeFirst","options","hashAlg","defaultHashAlg","hashLen","version","mh","multicodec"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst cbor = require('borc')\r\nconst multihashing = require('multihashing-async')\r\nconst CID = require('cids')\r\nconst isCircular = require('is-circular')\r\n\r\nconst resolver = require('./resolver')\r\n\r\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\r\nconst CID_CBOR_TAG = 42\r\n\r\nfunction tagCID (cid) {\r\n  if (typeof cid === 'string') {\r\n    cid = new CID(cid).buffer\r\n  } else if (CID.isCID(cid)) {\r\n    cid = cid.buffer\r\n  }\r\n\r\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([\r\n    Buffer.from('00', 'hex'), // thanks jdag\r\n    cid\r\n  ]))\r\n}\r\n\r\nconst decoder = new cbor.Decoder({\r\n  tags: {\r\n    [CID_CBOR_TAG]: (val) => {\r\n      // remove that 0\r\n      val = val.slice(1)\r\n      return new CID(val)\r\n    }\r\n  }\r\n})\r\n\r\nfunction replaceCIDbyTAG (dagNode) {\r\n  let circular\r\n  try {\r\n    circular = isCircular(dagNode)\r\n  } catch (e) {\r\n    circular = false\r\n  }\r\n  if (circular) {\r\n    throw new Error('The object passed has circular references')\r\n  }\r\n\r\n  function transform (obj) {\r\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\r\n      return obj\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n      return obj.map(transform)\r\n    }\r\n\r\n    if (CID.isCID(obj)) {\r\n      return tagCID(obj)\r\n    }\r\n\r\n    const keys = Object.keys(obj)\r\n\r\n    if (keys.length === 1 && keys[0] === '/') {\r\n      // Multiaddr encoding\r\n      // if (typeof link === 'string' && isMultiaddr(link)) {\r\n      //  link = new Multiaddr(link).buffer\r\n      // }\r\n\r\n      return tagCID(obj['/'])\r\n    } else if (keys.length > 0) {\r\n      // Recursive transform\r\n      const out = {}\r\n      keys.forEach((key) => {\r\n        if (typeof obj[key] === 'object') {\r\n          out[key] = transform(obj[key])\r\n        } else {\r\n          out[key] = obj[key]\r\n        }\r\n      })\r\n      return out\r\n    } else {\r\n      return obj\r\n    }\r\n  }\r\n\r\n  return transform(dagNode)\r\n}\r\n\r\nexports = module.exports\r\n\r\nexports.serialize = (dagNode, callback) => {\r\n  let serialized\r\n\r\n  try {\r\n    const dagNodeTagged = replaceCIDbyTAG(dagNode)\r\n    serialized = cbor.encode(dagNodeTagged)\r\n  } catch (err) {\r\n    return setImmediate(() => callback(err))\r\n  }\r\n  setImmediate(() => callback(null, serialized))\r\n}\r\n\r\nexports.deserialize = (data, callback) => {\r\n  let deserialized\r\n\r\n  try {\r\n    deserialized = decoder.decodeFirst(data)\r\n  } catch (err) {\r\n    return setImmediate(() => callback(err))\r\n  }\r\n\r\n  setImmediate(() => callback(null, deserialized))\r\n}\r\n\r\n/**\r\n * @callback CidCallback\r\n * @param {?Error} error - Error if getting the CID failed\r\n * @param {?CID} cid - CID if call was successful\r\n */\r\n/**\r\n * Get the CID of the DAG-Node.\r\n *\r\n * @param {Object} dagNode - Internal representation\r\n * @param {Object} [options] - Options to create the CID\r\n * @param {number} [options.version=1] - CID version number\r\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\r\n * @param {number} [options.hashLen] - Optionally trim the digest to this length\r\n * @param {CidCallback} callback - Callback that handles the return value\r\n * @returns {void}\r\n */\r\nexports.cid = (dagNode, options, callback) => {\r\n  if (typeof options === 'function') {\r\n    callback = options\r\n    options = {}\r\n  }\r\n  options = options || {}\r\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg\r\n  const hashLen = options.hashLen\r\n  const version = typeof options.version === 'undefined' ? 1 : options.version\r\n\r\n  exports.serialize(dagNode, (err, serialized) => {\r\n    if (err) return callback(err)\r\n    multihashing(serialized, hashAlg, hashLen, (err, mh) => {\r\n      if (err) return callback(err)\r\n      callback(null, new CID(version, resolver.multicodec, mh))\r\n    })\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}