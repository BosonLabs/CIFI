{"ast":null,"code":"'use strict';\n\nconst map = require('lodash.map');\n\nconst extend = require('xtend');\n\nconst codec = require('./codec');\n\nconst protocols = require('./protocols-table');\n\nconst varint = require('varint');\n\nconst bs58 = require('bs58');\n\nconst withIs = require('class-is');\n\nconst NotImplemented = new Error('Sorry, Not Implemented Yet.');\n/**\r\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\r\n * a Buffer, String or another Multiaddr instance\r\n * public key.\r\n * @class Multiaddr\r\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\r\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\nconst Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr);\n  } // default\n\n\n  if (addr == null) {\n    addr = '';\n  }\n\n  if (addr instanceof Buffer) {\n    /**\r\n     * @type {Buffer} - The raw bytes representing this multiaddress\r\n     */\n    this.buffer = codec.fromBuffer(addr);\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    this.buffer = codec.fromString(addr);\n  } else if (addr.buffer && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    this.buffer = codec.fromBuffer(addr.buffer); // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr');\n  }\n}, {\n  className: 'Multiaddr',\n  symbolName: '@multiformats/js-multiaddr/multiaddr'\n});\n/**\r\n * Returns Multiaddr as a String\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\n\nMultiaddr.prototype.toString = function toString() {\n  return codec.bufferToString(this.buffer);\n};\n/**\r\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\r\n *\r\n * @returns {{family: String, host: String, transport: String, port: String}}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\r\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }\r\n */\n\n\nMultiaddr.prototype.toOptions = function toOptions() {\n  const opts = {};\n  const parsed = this.toString().split('/');\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';\n  opts.host = parsed[2];\n  opts.transport = parsed[3];\n  opts.port = parsed[4];\n  return opts;\n};\n/**\r\n * Returns Multiaddr as a human-readable string\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\n\n\nMultiaddr.prototype.inspect = function inspect() {\n  return '<Multiaddr ' + this.buffer.toString('hex') + ' - ' + codec.bufferToString(this.buffer) + '>';\n};\n/**\r\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\r\n * left-to-right order. Each object contains the protocol code, protocol name,\r\n * and the size of its address space in bits.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Object>} protocols - All the protocols the address is composed of\r\n * @returns {Number} protocols[].code\r\n * @returns {Number} protocols[].size\r\n * @returns {String} protocols[].name\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\r\n * // [ { code: 4, size: 32, name: 'ip4' },\r\n * //   { code: 6, size: 16, name: 'tcp' } ]\r\n */\n\n\nMultiaddr.prototype.protos = function protos() {\n  return map(this.protoCodes(), function (code) {\n    return extend(protocols(code)); // copy to prevent users from modifying the internal objs.\n  });\n};\n/**\r\n * Returns the codes of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Number>} protocol codes\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\r\n * // [ 4, 6 ]\r\n */\n\n\nMultiaddr.prototype.protoCodes = function protoCodes() {\n  const codes = [];\n  const buf = this.buffer;\n  let i = 0;\n\n  while (i < buf.length) {\n    const code = varint.decode(buf, i);\n    const n = varint.decode.bytes;\n    const p = protocols(code);\n    const size = codec.sizeForAddr(p, buf.slice(i + n));\n    i += size + n;\n    codes.push(code);\n  }\n\n  return codes;\n};\n/**\r\n * Returns the names of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @return {Array.<String>} protocol names\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\r\n * // [ 'ip4', 'tcp' ]\r\n */\n\n\nMultiaddr.prototype.protoNames = function protoNames() {\n  return map(this.protos(), function (proto) {\n    return proto.name;\n  });\n};\n/**\r\n * Returns a tuple of parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {Buffer} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\r\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\r\n */\n\n\nMultiaddr.prototype.tuples = function tuples() {\n  return codec.bufferToTuples(this.buffer);\n};\n/**\r\n * Returns a tuple of string/number parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {(String|Number)} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\r\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\r\n */\n\n\nMultiaddr.prototype.stringTuples = function stringTuples() {\n  const t = codec.bufferToTuples(this.buffer);\n  return codec.tuplesToStringTuples(t);\n};\n/**\r\n * Encapsulates a Multiaddr in another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.toString()\r\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\r\n */\n\n\nMultiaddr.prototype.encapsulate = function encapsulate(addr) {\n  addr = Multiaddr(addr);\n  return Multiaddr(this.toString() + addr.toString());\n};\n/**\r\n * Decapsulates a Multiaddr from another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.decapsulate(mh2).toString()\r\n * // '/ip4/8.8.8.8/tcp/1080'\r\n */\n\n\nMultiaddr.prototype.decapsulate = function decapsulate(addr) {\n  addr = addr.toString();\n  const s = this.toString();\n  const i = s.lastIndexOf(addr);\n\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);\n  }\n\n  return Multiaddr(s.slice(0, i));\n};\n/**\r\n * Extract the peerId if the multiaddr contains one\r\n *\r\n * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\r\n *\r\n * // should return QmValidBase58string or null if the id is missing or invalid\r\n * const peerId = mh1.getPeerId()\r\n */\n\n\nMultiaddr.prototype.getPeerId = function getPeerId() {\n  let b58str = null;\n\n  try {\n    b58str = this.stringTuples().filter(tuple => {\n      if (tuple[0] === protocols.names['ipfs'].code) {\n        return true;\n      }\n    })[0][1];\n    bs58.decode(b58str);\n  } catch (e) {\n    b58str = null;\n  }\n\n  return b58str;\n};\n/**\r\n * Checks if two Multiaddrs are the same\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh1.equals(mh1)\r\n * // true\r\n *\r\n * mh1.equals(mh2)\r\n * // false\r\n */\n\n\nMultiaddr.prototype.equals = function equals(addr) {\n  return this.buffer.equals(addr.buffer);\n};\n/**\r\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\r\n * is left out: in Node (and most network systems) the protocol is unknowable\r\n * given only the address.\r\n *\r\n * Has to be a ThinWaist Address, otherwise throws error\r\n *\r\n * @returns {{family: String, address: String, port: String}}\r\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\r\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\r\n */\n\n\nMultiaddr.prototype.nodeAddress = function nodeAddress() {\n  if (!this.isThinWaistAddress()) {\n    throw new Error('Multiaddr must be \"thin waist\" address for nodeAddress.');\n  }\n\n  const codes = this.protoCodes();\n  const parts = this.toString().split('/').slice(1);\n  return {\n    family: codes[0] === 41 ? 'IPv6' : 'IPv4',\n    address: parts[1],\n    // ip addr\n    port: parts[3] // tcp or udp port\n\n  };\n};\n/**\r\n * Creates a Multiaddr from a node-friendly address object\r\n *\r\n * @param {String} addr\r\n * @param {String} transport\r\n * @returns {Multiaddr} multiaddr\r\n * @throws {Error} Throws error if addr is not truthy\r\n * @throws {Error} Throws error if transport is not truthy\r\n * @example\r\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\n\nMultiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {\n  if (!addr) throw new Error('requires node address object');\n  if (!transport) throw new Error('requires transport protocol');\n  const ip = addr.family === 'IPv6' ? 'ip6' : 'ip4';\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));\n}; // TODO find a better example, not sure about it's good enough\n\n/**\r\n * Returns if a Multiaddr is a Thin Waist address or not.\r\n *\r\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\r\n *\r\n * `{IPv4, IPv6}/{TCP, UDP}`\r\n *\r\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\r\n * @returns {Boolean} isThinWaistAddress\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\r\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\r\n * mh1.isThinWaistAddress()\r\n * // true\r\n * mh2.isThinWaistAddress()\r\n * // true\r\n * mh3.isThinWaistAddress()\r\n * // false\r\n */\n\n\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {\n  const protos = (addr || this).protos();\n\n  if (protos.length !== 2) {\n    return false;\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false;\n  }\n\n  if (protos[1].code !== 6 && protos[1].code !== 17) {\n    return false;\n  }\n\n  return true;\n}; // TODO rename this to something else than \"stupid string\"\n\n/**\r\n * Converts a \"stupid string\" into a Multiaddr.\r\n *\r\n * Stupid string format:\r\n * ```\r\n * <proto><IPv>://<IP Addr>[:<proto port>]\r\n * udp4://1.2.3.4:5678\r\n * ```\r\n *\r\n * @param {String} [str] - String in the \"stupid\" format\r\n * @throws {NotImplemented}\r\n * @returns {undefined}\r\n * @todo Not Implemented yet\r\n */\n\n\nMultiaddr.prototype.fromStupidString = function fromStupidString(str) {\n  throw NotImplemented;\n};\n/**\r\n * Object containing table, names and codes of all supported protocols.\r\n * To get the protocol values from a Multiaddr, you can use\r\n * [`.protos()`](#multiaddrprotos),\r\n * [`.protoCodes()`](#multiaddrprotocodes) or\r\n * [`.protoNames()`](#multiaddrprotonames)\r\n *\r\n * @instance\r\n * @returns {{table: Array, names: Object, codes: Object}}\r\n *\r\n */\n\n\nMultiaddr.protocols = protocols;\n/**\r\n * Returns if something is a Multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool} isName\r\n */\n\nMultiaddr.isName = function isName(addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false;\n  } // if a part of the multiaddr is resolvable, then return true\n\n\n  return addr.protos().some(proto => proto.resolvable);\n};\n/**\r\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n *\r\n * @param {Function} callback\r\n * @return {Bool} isName\r\n */\n\n\nMultiaddr.resolve = function resolve(addr, callback) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return callback(new Error('not a valid name'));\n  }\n  /*\r\n   * Needs more consideration from spec design:\r\n   *   - what to return\r\n   *   - how to achieve it in the browser?\r\n   */\n\n\n  return callback(new Error('not implemented yet'));\n};\n\nexports = module.exports = Multiaddr;","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/peer-info/node_modules/multiaddr/src/index.js"],"names":["map","require","extend","codec","protocols","varint","bs58","withIs","NotImplemented","Error","Multiaddr","proto","addr","Buffer","buffer","fromBuffer","String","fromString","protos","protoCodes","className","symbolName","prototype","toString","bufferToString","toOptions","opts","parsed","split","family","host","transport","port","inspect","code","codes","buf","i","length","decode","n","bytes","p","size","sizeForAddr","slice","push","protoNames","name","tuples","bufferToTuples","stringTuples","t","tuplesToStringTuples","encapsulate","decapsulate","s","lastIndexOf","getPeerId","b58str","filter","tuple","names","e","equals","nodeAddress","isThinWaistAddress","parts","address","fromNodeAddress","ip","join","fromStupidString","str","isName","isMultiaddr","some","resolvable","resolve","callback","exports","module"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst map = require('lodash.map')\r\nconst extend = require('xtend')\r\nconst codec = require('./codec')\r\nconst protocols = require('./protocols-table')\r\nconst varint = require('varint')\r\nconst bs58 = require('bs58')\r\nconst withIs = require('class-is')\r\n\r\nconst NotImplemented = new Error('Sorry, Not Implemented Yet.')\r\n\r\n/**\r\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\r\n * a Buffer, String or another Multiaddr instance\r\n * public key.\r\n * @class Multiaddr\r\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\r\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\r\nconst Multiaddr = withIs.proto(function (addr) {\r\n  if (!(this instanceof Multiaddr)) {\r\n    return new Multiaddr(addr)\r\n  }\r\n\r\n  // default\r\n  if (addr == null) {\r\n    addr = ''\r\n  }\r\n\r\n  if (addr instanceof Buffer) {\r\n    /**\r\n     * @type {Buffer} - The raw bytes representing this multiaddress\r\n     */\r\n    this.buffer = codec.fromBuffer(addr)\r\n  } else if (typeof addr === 'string' || addr instanceof String) {\r\n    this.buffer = codec.fromString(addr)\r\n  } else if (addr.buffer && addr.protos && addr.protoCodes) { // Multiaddr\r\n    this.buffer = codec.fromBuffer(addr.buffer) // validate + copy buffer\r\n  } else {\r\n    throw new Error('addr must be a string, Buffer, or another Multiaddr')\r\n  }\r\n}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })\r\n\r\n/**\r\n * Returns Multiaddr as a String\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\r\nMultiaddr.prototype.toString = function toString () {\r\n  return codec.bufferToString(this.buffer)\r\n}\r\n\r\n/**\r\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\r\n *\r\n * @returns {{family: String, host: String, transport: String, port: String}}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\r\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }\r\n */\r\nMultiaddr.prototype.toOptions = function toOptions () {\r\n  const opts = {}\r\n  const parsed = this.toString().split('/')\r\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'\r\n  opts.host = parsed[2]\r\n  opts.transport = parsed[3]\r\n  opts.port = parsed[4]\r\n  return opts\r\n}\r\n\r\n/**\r\n * Returns Multiaddr as a human-readable string\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\r\nMultiaddr.prototype.inspect = function inspect () {\r\n  return '<Multiaddr ' +\r\n    this.buffer.toString('hex') + ' - ' +\r\n    codec.bufferToString(this.buffer) + '>'\r\n}\r\n\r\n/**\r\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\r\n * left-to-right order. Each object contains the protocol code, protocol name,\r\n * and the size of its address space in bits.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Object>} protocols - All the protocols the address is composed of\r\n * @returns {Number} protocols[].code\r\n * @returns {Number} protocols[].size\r\n * @returns {String} protocols[].name\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\r\n * // [ { code: 4, size: 32, name: 'ip4' },\r\n * //   { code: 6, size: 16, name: 'tcp' } ]\r\n */\r\nMultiaddr.prototype.protos = function protos () {\r\n  return map(this.protoCodes(), function (code) {\r\n    return extend(protocols(code))\r\n    // copy to prevent users from modifying the internal objs.\r\n  })\r\n}\r\n\r\n/**\r\n * Returns the codes of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Number>} protocol codes\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\r\n * // [ 4, 6 ]\r\n */\r\nMultiaddr.prototype.protoCodes = function protoCodes () {\r\n  const codes = []\r\n  const buf = this.buffer\r\n  let i = 0\r\n  while (i < buf.length) {\r\n    const code = varint.decode(buf, i)\r\n    const n = varint.decode.bytes\r\n\r\n    const p = protocols(code)\r\n    const size = codec.sizeForAddr(p, buf.slice(i + n))\r\n\r\n    i += (size + n)\r\n    codes.push(code)\r\n  }\r\n\r\n  return codes\r\n}\r\n\r\n/**\r\n * Returns the names of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @return {Array.<String>} protocol names\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\r\n * // [ 'ip4', 'tcp' ]\r\n */\r\nMultiaddr.prototype.protoNames = function protoNames () {\r\n  return map(this.protos(), function (proto) {\r\n    return proto.name\r\n  })\r\n}\r\n\r\n/**\r\n * Returns a tuple of parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {Buffer} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\r\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\r\n */\r\nMultiaddr.prototype.tuples = function tuples () {\r\n  return codec.bufferToTuples(this.buffer)\r\n}\r\n\r\n/**\r\n * Returns a tuple of string/number parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {(String|Number)} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\r\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\r\n */\r\nMultiaddr.prototype.stringTuples = function stringTuples () {\r\n  const t = codec.bufferToTuples(this.buffer)\r\n  return codec.tuplesToStringTuples(t)\r\n}\r\n\r\n/**\r\n * Encapsulates a Multiaddr in another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.toString()\r\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\r\n */\r\nMultiaddr.prototype.encapsulate = function encapsulate (addr) {\r\n  addr = Multiaddr(addr)\r\n  return Multiaddr(this.toString() + addr.toString())\r\n}\r\n\r\n/**\r\n * Decapsulates a Multiaddr from another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.decapsulate(mh2).toString()\r\n * // '/ip4/8.8.8.8/tcp/1080'\r\n */\r\nMultiaddr.prototype.decapsulate = function decapsulate (addr) {\r\n  addr = addr.toString()\r\n  const s = this.toString()\r\n  const i = s.lastIndexOf(addr)\r\n  if (i < 0) {\r\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)\r\n  }\r\n  return Multiaddr(s.slice(0, i))\r\n}\r\n\r\n/**\r\n * Extract the peerId if the multiaddr contains one\r\n *\r\n * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\r\n *\r\n * // should return QmValidBase58string or null if the id is missing or invalid\r\n * const peerId = mh1.getPeerId()\r\n */\r\nMultiaddr.prototype.getPeerId = function getPeerId () {\r\n  let b58str = null\r\n  try {\r\n    b58str = this.stringTuples().filter((tuple) => {\r\n      if (tuple[0] === protocols.names['ipfs'].code) {\r\n        return true\r\n      }\r\n    })[0][1]\r\n\r\n    bs58.decode(b58str)\r\n  } catch (e) {\r\n    b58str = null\r\n  }\r\n\r\n  return b58str\r\n}\r\n\r\n/**\r\n * Checks if two Multiaddrs are the same\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh1.equals(mh1)\r\n * // true\r\n *\r\n * mh1.equals(mh2)\r\n * // false\r\n */\r\nMultiaddr.prototype.equals = function equals (addr) {\r\n  return this.buffer.equals(addr.buffer)\r\n}\r\n\r\n/**\r\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\r\n * is left out: in Node (and most network systems) the protocol is unknowable\r\n * given only the address.\r\n *\r\n * Has to be a ThinWaist Address, otherwise throws error\r\n *\r\n * @returns {{family: String, address: String, port: String}}\r\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\r\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\r\n */\r\nMultiaddr.prototype.nodeAddress = function nodeAddress () {\r\n  if (!this.isThinWaistAddress()) {\r\n    throw new Error('Multiaddr must be \"thin waist\" address for nodeAddress.')\r\n  }\r\n\r\n  const codes = this.protoCodes()\r\n  const parts = this.toString().split('/').slice(1)\r\n  return {\r\n    family: (codes[0] === 41) ? 'IPv6' : 'IPv4',\r\n    address: parts[1], // ip addr\r\n    port: parts[3] // tcp or udp port\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a Multiaddr from a node-friendly address object\r\n *\r\n * @param {String} addr\r\n * @param {String} transport\r\n * @returns {Multiaddr} multiaddr\r\n * @throws {Error} Throws error if addr is not truthy\r\n * @throws {Error} Throws error if transport is not truthy\r\n * @example\r\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\r\nMultiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {\r\n  if (!addr) throw new Error('requires node address object')\r\n  if (!transport) throw new Error('requires transport protocol')\r\n  const ip = (addr.family === 'IPv6') ? 'ip6' : 'ip4'\r\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))\r\n}\r\n\r\n// TODO find a better example, not sure about it's good enough\r\n/**\r\n * Returns if a Multiaddr is a Thin Waist address or not.\r\n *\r\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\r\n *\r\n * `{IPv4, IPv6}/{TCP, UDP}`\r\n *\r\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\r\n * @returns {Boolean} isThinWaistAddress\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\r\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\r\n * mh1.isThinWaistAddress()\r\n * // true\r\n * mh2.isThinWaistAddress()\r\n * // true\r\n * mh3.isThinWaistAddress()\r\n * // false\r\n */\r\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {\r\n  const protos = (addr || this).protos()\r\n\r\n  if (protos.length !== 2) {\r\n    return false\r\n  }\r\n\r\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\r\n    return false\r\n  }\r\n  if (protos[1].code !== 6 && protos[1].code !== 17) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\n// TODO rename this to something else than \"stupid string\"\r\n/**\r\n * Converts a \"stupid string\" into a Multiaddr.\r\n *\r\n * Stupid string format:\r\n * ```\r\n * <proto><IPv>://<IP Addr>[:<proto port>]\r\n * udp4://1.2.3.4:5678\r\n * ```\r\n *\r\n * @param {String} [str] - String in the \"stupid\" format\r\n * @throws {NotImplemented}\r\n * @returns {undefined}\r\n * @todo Not Implemented yet\r\n */\r\nMultiaddr.prototype.fromStupidString = function fromStupidString (str) {\r\n  throw NotImplemented\r\n}\r\n\r\n/**\r\n * Object containing table, names and codes of all supported protocols.\r\n * To get the protocol values from a Multiaddr, you can use\r\n * [`.protos()`](#multiaddrprotos),\r\n * [`.protoCodes()`](#multiaddrprotocodes) or\r\n * [`.protoNames()`](#multiaddrprotonames)\r\n *\r\n * @instance\r\n * @returns {{table: Array, names: Object, codes: Object}}\r\n *\r\n */\r\nMultiaddr.protocols = protocols\r\n\r\n/**\r\n * Returns if something is a Multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool} isName\r\n */\r\nMultiaddr.isName = function isName (addr) {\r\n  if (!Multiaddr.isMultiaddr(addr)) {\r\n    return false\r\n  }\r\n\r\n  // if a part of the multiaddr is resolvable, then return true\r\n  return addr.protos().some((proto) => proto.resolvable)\r\n}\r\n\r\n/**\r\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n *\r\n * @param {Function} callback\r\n * @return {Bool} isName\r\n */\r\nMultiaddr.resolve = function resolve (addr, callback) {\r\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\r\n    return callback(new Error('not a valid name'))\r\n  }\r\n\r\n  /*\r\n   * Needs more consideration from spec design:\r\n   *   - what to return\r\n   *   - how to achieve it in the browser?\r\n   */\r\n  return callback(new Error('not implemented yet'))\r\n}\r\n\r\nexports = module.exports = Multiaddr\r\n"]},"metadata":{},"sourceType":"script"}