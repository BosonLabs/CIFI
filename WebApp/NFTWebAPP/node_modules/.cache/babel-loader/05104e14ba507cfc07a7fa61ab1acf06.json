{"ast":null,"code":"function convertFilePathToBaseDirectoryPath(sourcePath, filePath) {\n  let newString = sourcePath.startsWith('./') ? sourcePath.substring(2) : sourcePath; //make sure there isn't a dangling / to throw a false positive into the mix\n\n  const lastIndexOfDirectory = newString.lastIndexOf('/');\n\n  if (lastIndexOfDirectory === -1) {\n    return filePath;\n  }\n\n  const lengthOfSource = sourcePath.length; //only trim if the / is the last character in the string\n\n  if (lastIndexOfDirectory === lengthOfSource - 1) {\n    newString = sourcePath.slice(0, -1);\n  } //now that we're sure of no false positive, let's check and see where the \"root\" directory is\n\n\n  const newLastIndex = newString.lastIndexOf('/');\n\n  if (newLastIndex === -1) {\n    return newString;\n  } else {\n    const pathGarbage = newString.substring(0, newLastIndex + 1);\n    newString = filePath.split(pathGarbage)[1];\n  }\n\n  return newString;\n}\n\nmodule.exports = convertFilePathToBaseDirectoryPath;","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/base-path-converter/index.js"],"names":["convertFilePathToBaseDirectoryPath","sourcePath","filePath","newString","startsWith","substring","lastIndexOfDirectory","lastIndexOf","lengthOfSource","length","slice","newLastIndex","pathGarbage","split","module","exports"],"mappings":"AAAA,SAASA,kCAAT,CAA4CC,UAA5C,EAAwDC,QAAxD,EAAkE;AAC9D,MAAIC,SAAS,GAAIF,UAAU,CAACG,UAAX,CAAsB,IAAtB,IAA8BH,UAAU,CAACI,SAAX,CAAqB,CAArB,CAA9B,GAAwDJ,UAAzE,CAD8D,CAE9D;;AACA,QAAMK,oBAAoB,GAAGH,SAAS,CAACI,WAAV,CAAsB,GAAtB,CAA7B;;AACA,MAAGD,oBAAoB,KAAK,CAAC,CAA7B,EAAgC;AAC5B,WAAOJ,QAAP;AACH;;AACD,QAAMM,cAAc,GAAGP,UAAU,CAACQ,MAAlC,CAP8D,CAQ9D;;AACA,MAAIH,oBAAoB,KAAME,cAAc,GAAG,CAA/C,EAAmD;AAC/CL,IAAAA,SAAS,GAAGF,UAAU,CAACS,KAAX,CAAiB,CAAjB,EAAmB,CAAC,CAApB,CAAZ;AACH,GAX6D,CAa9D;;;AACA,QAAMC,YAAY,GAAGR,SAAS,CAACI,WAAV,CAAsB,GAAtB,CAArB;;AACA,MAAKI,YAAY,KAAK,CAAC,CAAvB,EAA0B;AACtB,WAAOR,SAAP;AACH,GAFD,MAEO;AACH,UAAMS,WAAW,GAAGT,SAAS,CAACE,SAAV,CAAoB,CAApB,EAAuBM,YAAY,GAAG,CAAtC,CAApB;AACAR,IAAAA,SAAS,GAAGD,QAAQ,CAACW,KAAT,CAAeD,WAAf,EAA4B,CAA5B,CAAZ;AACH;;AAED,SAAOT,SAAP;AACH;;AAEDW,MAAM,CAACC,OAAP,GAAiBf,kCAAjB","sourcesContent":["function convertFilePathToBaseDirectoryPath(sourcePath, filePath) {\n    let newString = (sourcePath.startsWith('./') ? sourcePath.substring(2) : sourcePath);\n    //make sure there isn't a dangling / to throw a false positive into the mix\n    const lastIndexOfDirectory = newString.lastIndexOf('/');\n    if(lastIndexOfDirectory === -1) {\n        return filePath;\n    }\n    const lengthOfSource = sourcePath.length;\n    //only trim if the / is the last character in the string\n    if (lastIndexOfDirectory === (lengthOfSource - 1)) {\n        newString = sourcePath.slice(0,-1);\n    }\n\n    //now that we're sure of no false positive, let's check and see where the \"root\" directory is\n    const newLastIndex = newString.lastIndexOf('/');\n    if ( newLastIndex === -1) {\n        return newString;\n    } else {\n        const pathGarbage = newString.substring(0, newLastIndex + 1);\n        newString = filePath.split(pathGarbage)[1];\n    }\n\n    return newString;\n}\n\nmodule.exports = convertFilePathToBaseDirectoryPath"]},"metadata":{},"sourceType":"script"}