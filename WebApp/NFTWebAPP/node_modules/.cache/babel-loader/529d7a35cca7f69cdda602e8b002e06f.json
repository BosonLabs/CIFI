{"ast":null,"code":"'use strict';\n\nconst promisify = require('promisify-es6');\n\nconst ConcatStream = require('concat-stream');\n\nconst once = require('once');\n\nconst isStream = require('is-stream');\n\nconst OtherBuffer = require('buffer').Buffer;\n\nconst isSource = require('is-pull-stream').isSource;\n\nconst FileResultStreamConverter = require('../utils/file-result-stream-converter');\n\nconst SendFilesStream = require('../utils/send-files-stream');\n\nmodule.exports = send => {\n  const createAddStream = SendFilesStream(send, 'add');\n  const add = promisify((_files, options, _callback) => {\n    if (typeof options === 'function') {\n      _callback = options;\n      options = null;\n    }\n\n    const callback = once(_callback);\n\n    if (!options) {\n      options = {};\n    }\n\n    options.converter = FileResultStreamConverter;\n    const ok = Buffer.isBuffer(_files) || isStream.readable(_files) || Array.isArray(_files) || OtherBuffer.isBuffer(_files) || typeof _files === 'object' || isSource(_files);\n\n    if (!ok) {\n      return callback(new Error('first arg must be a buffer, readable stream, pull stream, an object or array of objects'));\n    }\n\n    const files = [].concat(_files);\n    const stream = createAddStream({\n      qs: options\n    });\n    const concat = ConcatStream(result => callback(null, result));\n    stream.once('error', callback);\n    stream.pipe(concat);\n    files.forEach(file => stream.write(file));\n    stream.end();\n  });\n  return function () {\n    const args = Array.from(arguments); // If we files.add(<pull stream>), then promisify thinks the pull stream is\n    // a callback! Add an empty options object in this case so that a promise\n    // is returned.\n\n    if (args.length === 1 && isSource(args[0])) {\n      args.push({});\n    }\n\n    return add.apply(null, args);\n  };\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/algosigner-react/CIFI/WebApp/NFTWebAPP/node_modules/ipfs-api/src/files/add.js"],"names":["promisify","require","ConcatStream","once","isStream","OtherBuffer","Buffer","isSource","FileResultStreamConverter","SendFilesStream","module","exports","send","createAddStream","add","_files","options","_callback","callback","converter","ok","isBuffer","readable","Array","isArray","Error","files","concat","stream","qs","result","pipe","forEach","file","write","end","args","from","arguments","length","push","apply"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,QAAD,CAAP,CAAkBK,MAAtC;;AACA,MAAMC,QAAQ,GAAGN,OAAO,CAAC,gBAAD,CAAP,CAA0BM,QAA3C;;AACA,MAAMC,yBAAyB,GAAGP,OAAO,CAAC,uCAAD,CAAzC;;AACA,MAAMQ,eAAe,GAAGR,OAAO,CAAC,4BAAD,CAA/B;;AAEAS,MAAM,CAACC,OAAP,GAAkBC,IAAD,IAAU;AACzB,QAAMC,eAAe,GAAGJ,eAAe,CAACG,IAAD,EAAO,KAAP,CAAvC;AAEA,QAAME,GAAG,GAAGd,SAAS,CAAC,CAACe,MAAD,EAASC,OAAT,EAAkBC,SAAlB,KAAgC;AACpD,QAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,MAAAA,SAAS,GAAGD,OAAZ;AACAA,MAAAA,OAAO,GAAG,IAAV;AACD;;AAED,UAAME,QAAQ,GAAGf,IAAI,CAACc,SAAD,CAArB;;AAEA,QAAI,CAACD,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,EAAV;AACD;;AACDA,IAAAA,OAAO,CAACG,SAAR,GAAoBX,yBAApB;AAEA,UAAMY,EAAE,GAAGd,MAAM,CAACe,QAAP,CAAgBN,MAAhB,KACAX,QAAQ,CAACkB,QAAT,CAAkBP,MAAlB,CADA,IAEAQ,KAAK,CAACC,OAAN,CAAcT,MAAd,CAFA,IAGAV,WAAW,CAACgB,QAAZ,CAAqBN,MAArB,CAHA,IAIA,OAAOA,MAAP,KAAkB,QAJlB,IAKAR,QAAQ,CAACQ,MAAD,CALnB;;AAOA,QAAI,CAACK,EAAL,EAAS;AACP,aAAOF,QAAQ,CAAC,IAAIO,KAAJ,CAAU,yFAAV,CAAD,CAAf;AACD;;AAED,UAAMC,KAAK,GAAG,GAAGC,MAAH,CAAUZ,MAAV,CAAd;AAEA,UAAMa,MAAM,GAAGf,eAAe,CAAC;AAAEgB,MAAAA,EAAE,EAAEb;AAAN,KAAD,CAA9B;AACA,UAAMW,MAAM,GAAGzB,YAAY,CAAE4B,MAAD,IAAYZ,QAAQ,CAAC,IAAD,EAAOY,MAAP,CAArB,CAA3B;AACAF,IAAAA,MAAM,CAACzB,IAAP,CAAY,OAAZ,EAAqBe,QAArB;AACAU,IAAAA,MAAM,CAACG,IAAP,CAAYJ,MAAZ;AAEAD,IAAAA,KAAK,CAACM,OAAN,CAAeC,IAAD,IAAUL,MAAM,CAACM,KAAP,CAAaD,IAAb,CAAxB;AACAL,IAAAA,MAAM,CAACO,GAAP;AACD,GAjCoB,CAArB;AAmCA,SAAO,YAAY;AACjB,UAAMC,IAAI,GAAGb,KAAK,CAACc,IAAN,CAAWC,SAAX,CAAb,CADiB,CAGjB;AACA;AACA;;AACA,QAAIF,IAAI,CAACG,MAAL,KAAgB,CAAhB,IAAqBhC,QAAQ,CAAC6B,IAAI,CAAC,CAAD,CAAL,CAAjC,EAA4C;AAC1CA,MAAAA,IAAI,CAACI,IAAL,CAAU,EAAV;AACD;;AAED,WAAO1B,GAAG,CAAC2B,KAAJ,CAAU,IAAV,EAAgBL,IAAhB,CAAP;AACD,GAXD;AAYD,CAlDD","sourcesContent":["'use strict'\r\n\r\nconst promisify = require('promisify-es6')\r\nconst ConcatStream = require('concat-stream')\r\nconst once = require('once')\r\nconst isStream = require('is-stream')\r\nconst OtherBuffer = require('buffer').Buffer\r\nconst isSource = require('is-pull-stream').isSource\r\nconst FileResultStreamConverter = require('../utils/file-result-stream-converter')\r\nconst SendFilesStream = require('../utils/send-files-stream')\r\n\r\nmodule.exports = (send) => {\r\n  const createAddStream = SendFilesStream(send, 'add')\r\n\r\n  const add = promisify((_files, options, _callback) => {\r\n    if (typeof options === 'function') {\r\n      _callback = options\r\n      options = null\r\n    }\r\n\r\n    const callback = once(_callback)\r\n\r\n    if (!options) {\r\n      options = {}\r\n    }\r\n    options.converter = FileResultStreamConverter\r\n\r\n    const ok = Buffer.isBuffer(_files) ||\r\n               isStream.readable(_files) ||\r\n               Array.isArray(_files) ||\r\n               OtherBuffer.isBuffer(_files) ||\r\n               typeof _files === 'object' ||\r\n               isSource(_files)\r\n\r\n    if (!ok) {\r\n      return callback(new Error('first arg must be a buffer, readable stream, pull stream, an object or array of objects'))\r\n    }\r\n\r\n    const files = [].concat(_files)\r\n\r\n    const stream = createAddStream({ qs: options })\r\n    const concat = ConcatStream((result) => callback(null, result))\r\n    stream.once('error', callback)\r\n    stream.pipe(concat)\r\n\r\n    files.forEach((file) => stream.write(file))\r\n    stream.end()\r\n  })\r\n\r\n  return function () {\r\n    const args = Array.from(arguments)\r\n\r\n    // If we files.add(<pull stream>), then promisify thinks the pull stream is\r\n    // a callback! Add an empty options object in this case so that a promise\r\n    // is returned.\r\n    if (args.length === 1 && isSource(args[0])) {\r\n      args.push({})\r\n    }\r\n\r\n    return add.apply(null, args)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}