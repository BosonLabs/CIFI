{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst encoding = require('./encoding/encoding');\n\nconst logic = require('./logic/logic');\n\nconst multisig = require('./multisig');\n\nconst utils = require('./utils/utils');\n\nconst txnBuilder = require('./transaction');\n/**\n LogicSig implementation\n */\n\n\nclass LogicSig {\n  constructor(program, args) {\n    this.tag = Buffer.from(\"Program\");\n\n    if (!logic.checkProgram(program, args)) {\n      throw new Error(\"Invalid program\");\n    }\n\n    if (args) {\n      function checkType(arg) {\n        let theType = typeof arg;\n        return theType == \"string\" || theType == \"number\" || arg.constructor == Uint8Array || Buffer.isBuffer(arg);\n      }\n\n      if (!Array.isArray(args) || !args.every(checkType)) {\n        throw new TypeError(\"Invalid arguments\");\n      }\n    }\n\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n\n  get_obj_for_encoding() {\n    let obj = {\n      l: this.logic\n    };\n\n    if (this.args) {\n      obj[\"arg\"] = this.args;\n    }\n\n    if (this.sig) {\n      obj[\"sig\"] = this.sig;\n    } else if (this.msig) {\n      obj[\"msig\"] = this.msig;\n    }\n\n    return obj;\n  }\n\n  static from_obj_for_encoding(encoded) {\n    let lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n  /**\n   * Performs signature verification\n   * @param {Uint8Array} publicKey Verification key (derived from sender address or escrow address)\n   * @returns {boolean}\n   */\n\n\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n\n    try {\n      logic.checkProgram(this.logic, this.args);\n    } catch (e) {\n      return false;\n    }\n\n    let toBeSigned = utils.concatArrays(this.tag, this.logic);\n\n    if (!this.sig && !this.msig) {\n      let hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n\n    return multisig.verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns {string} String representation of the address\n   */\n\n\n  address() {\n    let toBeSigned = utils.concatArrays(this.tag, this.logic);\n    let hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(hash);\n  }\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param {Uint8Array} secretKey Secret key to sign with\n   * @param {Object} msig Multisig account as {version, threshold, addrs}\n   */\n\n\n  sign(secretKey, msig) {\n    if (msig === undefined) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      let subsigs = msig.addrs.map(addr => {\n        return {\n          \"pk\": address.decodeAddress(addr).publicKey\n        };\n      });\n      this.msig = {\n        \"v\": msig.version,\n        \"thr\": msig.threshold,\n        \"subsig\": subsigs\n      };\n      let [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n  /**\n   * Appends a signature to multi signature\n   * @param {Uint8Array} secretKey Secret key to sign with\n   */\n\n\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error(\"no multisig present\");\n    }\n\n    let [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n\n  signProgram(secretKey) {\n    let toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    let myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n\n    for (let i = 0; i < msig.subsig.length; i++) {\n      let pk = msig.subsig[i].pk;\n\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index == -1) {\n      throw new Error(\"invalid secret key\");\n    }\n\n    let sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n  static fromByte(encoded) {\n    let decoded_obj = encoding.decode(encoded);\n    return LogicSig.from_obj_for_encoding(decoded_obj);\n  }\n\n}\n/**\n * makeLogicSig creates LogicSig object from program and arguments\n *\n * @param {Uint8Array} program Program to make LogicSig from\n * @param {[Uint8Array]} args Arguments as array of Uint8Array\n * @returns {LogicSig} LogicSig object\n */\n\n\nfunction makeLogicSig(program, args) {\n  return new LogicSig(program, args);\n}\n/**\n * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} dictionary containing constructor arguments for a transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\n\n\nfunction signLogicSigTransaction(txn, lsig) {\n  if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n    throw new Error(\"invalid signature\");\n  }\n\n  let algoTxn = new txnBuilder.Transaction(txn);\n  return signLogicSigTransactionObject(algoTxn, lsig);\n}\n/**\n * signLogicSigTransactionObject takes transaction.Transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn transaction.Transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n */\n\n\nfunction signLogicSigTransactionObject(txn, lsig) {\n  let lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding()\n  };\n  return {\n    \"txID\": txn.txID().toString(),\n    \"blob\": encoding.encode(lstx)\n  };\n}\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\n\n\nfunction logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from(\"ProgData\");\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from contract address\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param contractAddress string representation of teal contract address (program hash)\n */\n\nfunction tealSign(sk, data, contractAddress) {\n  const parts = utils.concatArrays(address.decodeAddress(contractAddress).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.sign(toBeSigned, sk);\n}\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\n\n\nfunction tealSignFromProgram(sk, data, program) {\n  const lsig = makeLogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}\n\nmodule.exports = {\n  LogicSig,\n  makeLogicSig,\n  signLogicSigTransaction,\n  signLogicSigTransactionObject,\n  logicSigFromByte,\n  tealSign,\n  tealSignFromProgram\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicsig.js"],"names":["Buffer","require","nacl","address","encoding","logic","multisig","utils","txnBuilder","LogicSig","constructor","program","args","tag","from","checkProgram","Error","checkType","arg","theType","Uint8Array","isBuffer","Array","isArray","every","TypeError","sig","undefined","msig","get_obj_for_encoding","obj","l","from_obj_for_encoding","encoded","lsig","verify","publicKey","e","toBeSigned","concatArrays","hash","genericHash","arrayEqual","verifyMultisig","encodeAddress","sign","secretKey","signProgram","subsigs","addrs","map","addr","decodeAddress","version","threshold","index","singleSignMultisig","subsig","s","appendToMultisig","myPk","keyPairFromSecretKey","i","length","pk","toByte","encode","fromByte","decoded_obj","decode","makeLogicSig","signLogicSigTransaction","txn","algoTxn","Transaction","signLogicSigTransactionObject","lstx","txID","toString","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","data","contractAddress","parts","tealSignFromProgram","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst encoding = require('./encoding/encoding');\nconst logic = require('./logic/logic');\nconst multisig = require('./multisig');\nconst utils = require('./utils/utils');\nconst txnBuilder = require('./transaction');\n\n/**\n LogicSig implementation\n */\n\nclass LogicSig {\n    constructor(program, args) {\n        this.tag = Buffer.from(\"Program\");\n\n        if (!logic.checkProgram(program, args)) {\n            throw new Error(\"Invalid program\");\n        }\n        if (args) {\n            function checkType(arg) {\n                let theType = typeof arg;\n                return ((theType == \"string\") || (theType == \"number\") || (arg.constructor == Uint8Array) || (Buffer.isBuffer(arg)));\n            }\n            if (!Array.isArray(args) || !args.every(checkType)) {\n                throw new TypeError(\"Invalid arguments\");\n            }\n        }\n\n        this.logic = program;\n        this.args = args;\n        this.sig = undefined;\n        this.msig = undefined;\n    }\n\n    get_obj_for_encoding() {\n        let obj = {\n            l: this.logic,\n        }\n        if (this.args) {\n            obj[\"arg\"] = this.args;\n        }\n        if (this.sig) {\n            obj[\"sig\"] = this.sig;\n        } else if (this.msig) {\n            obj[\"msig\"] = this.msig;\n        }\n        return obj;\n    }\n\n    static from_obj_for_encoding(encoded) {\n        let lsig = new LogicSig(encoded.l, encoded.arg);\n        lsig.sig = encoded.sig;\n        lsig.msig = encoded.msig;\n        return lsig;\n    }\n\n    /**\n     * Performs signature verification\n     * @param {Uint8Array} publicKey Verification key (derived from sender address or escrow address)\n     * @returns {boolean}\n     */\n    verify(publicKey) {\n        if (this.sig && this.msig) {\n            return false;\n        }\n\n        try {\n            logic.checkProgram(this.logic, this.args);\n        } catch (e) {\n            return false;\n        }\n\n        let toBeSigned = utils.concatArrays(this.tag, this.logic);\n\n        if (!this.sig && !this.msig) {\n            let hash = nacl.genericHash(toBeSigned);\n            return utils.arrayEqual(hash, publicKey)\n        }\n\n        if (this.sig) {\n            return nacl.verify(toBeSigned, this.sig, publicKey);\n        }\n\n        return multisig.verifyMultisig(toBeSigned, this.msig, publicKey);\n    }\n\n    /**\n     * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n     * @returns {string} String representation of the address\n     */\n    address() {\n        let toBeSigned = utils.concatArrays(this.tag, this.logic);\n        let hash = nacl.genericHash(toBeSigned);\n        return address.encodeAddress(hash);\n    }\n\n    /**\n     * Creates signature (if no msig provided) or multi signature otherwise\n     * @param {Uint8Array} secretKey Secret key to sign with\n     * @param {Object} msig Multisig account as {version, threshold, addrs}\n     */\n    sign(secretKey, msig) {\n        if (msig === undefined) {\n            this.sig = this.signProgram(secretKey);\n        } else {\n            let subsigs = msig.addrs.map(addr => {\n                return {\"pk\": address.decodeAddress(addr).publicKey};\n            });\n\n            this.msig = {\n                \"v\": msig.version,\n                \"thr\": msig.threshold,\n                \"subsig\": subsigs\n            };\n\n            let [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n            this.msig.subsig[index].s = sig;\n        }\n    }\n\n    /**\n     * Appends a signature to multi signature\n     * @param {Uint8Array} secretKey Secret key to sign with\n     */\n    appendToMultisig(secretKey) {\n        if (this.msig === undefined) {\n            throw new Error(\"no multisig present\");\n        }\n        let [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n        this.msig.subsig[index].s = sig;\n    }\n\n    signProgram(secretKey) {\n        let toBeSigned = utils.concatArrays(this.tag, this.logic);\n        const sig = nacl.sign(toBeSigned, secretKey);\n        return sig;\n    }\n\n    singleSignMultisig(secretKey, msig) {\n        let index = -1;\n        let myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n        for (let i = 0; i < msig.subsig.length; i++) {\n            let pk = msig.subsig[i].pk;\n            if (utils.arrayEqual(pk, myPk)) {\n                index = i;\n                break;\n            }\n        }\n        if (index == -1) {\n            throw new Error(\"invalid secret key\");\n        }\n        let sig = this.signProgram(secretKey);\n        return [sig, index];\n    }\n\n    toByte() {\n        return encoding.encode(this.get_obj_for_encoding());\n    }\n\n    static fromByte(encoded) {\n        let decoded_obj = encoding.decode(encoded);\n        return LogicSig.from_obj_for_encoding(decoded_obj);\n    }\n}\n\n/**\n * makeLogicSig creates LogicSig object from program and arguments\n *\n * @param {Uint8Array} program Program to make LogicSig from\n * @param {[Uint8Array]} args Arguments as array of Uint8Array\n * @returns {LogicSig} LogicSig object\n */\nfunction makeLogicSig(program, args) {\n    return new LogicSig(program, args);\n}\n\n/**\n * signLogicSigTransaction takes  a raw transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} dictionary containing constructor arguments for a transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nfunction signLogicSigTransaction(txn, lsig) {\n    if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n        throw new Error(\"invalid signature\");\n    }\n    let algoTxn = new txnBuilder.Transaction(txn);\n    return signLogicSigTransactionObject(algoTxn, lsig);\n}\n\n/**\n * signLogicSigTransactionObject takes transaction.Transaction and a LogicSig object and returns a logicsig\n * transaction which is a blob representing a transaction and logicsig object.\n * @param {Object} txn transaction.Transaction\n * @param {LogicSig} lsig logicsig object\n * @returns {Object} Object containing txID and blob representing signed transaction.\n */\nfunction signLogicSigTransactionObject(txn, lsig) {\n    let lstx = {\n        lsig: lsig.get_obj_for_encoding(),\n        txn: txn.get_obj_for_encoding()\n    };\n\n    return {\n        \"txID\": txn.txID().toString(),\n        \"blob\": encoding.encode(lstx)\n    };\n}\n\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nfunction logicSigFromByte(encoded) {\n    return LogicSig.fromByte(encoded);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from(\"ProgData\");\n\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from contract address\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param contractAddress string representation of teal contract address (program hash)\n */\nfunction tealSign(sk, data, contractAddress) {\n    const parts = utils.concatArrays(address.decodeAddress(contractAddress).publicKey, data);\n    const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n    return nacl.sign(toBeSigned, sk);\n}\n\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\nfunction tealSignFromProgram(sk, data, program) {\n    const lsig = makeLogicSig(program);\n    const contractAddress = lsig.address();\n    return tealSign(sk, data, contractAddress);\n}\n\nmodule.exports = {\n    LogicSig,\n    makeLogicSig,\n    signLogicSigTransaction,\n    signLogicSigTransactionObject,\n    logicSigFromByte,\n    tealSign,\n    tealSignFromProgram,\n};\n"]},"metadata":{},"sourceType":"script"}