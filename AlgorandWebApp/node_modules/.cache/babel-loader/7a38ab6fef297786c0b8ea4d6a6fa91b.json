{"ast":null,"code":"const {\n  Buffer\n} = require(\"buffer\");\n\nconst txnBuilder = require('./transaction');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst encoding = require('./encoding/encoding');\n\nconst address = require('./encoding/address');\n\nconst utils = require('./utils/utils');\n\nconst ALGORAND_MAX_TX_GROUP_SIZE = 16;\n/**\n * Aux class for group id calculation of a group of transactions\n */\n\nclass TxGroup {\n  constructor(hashes) {\n    if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {\n      let errorMsg = hashes.length.toString() + \" transactions grouped together but max group size is \" + ALGORAND_MAX_TX_GROUP_SIZE.toString();\n      throw Error(errorMsg);\n    }\n\n    this.name = \"Transaction group\";\n    this.tag = Buffer.from(\"TG\");\n    this.txGroupHashes = hashes;\n  }\n\n  get_obj_for_encoding() {\n    const txgroup = {\n      \"txlist\": this.txGroupHashes\n    };\n    return txgroup;\n  }\n\n  static from_obj_for_encoding(txgroupForEnc) {\n    const txn = Object.create(this.prototype);\n    txn.name = \"Transaction group\";\n    txn.tag = Buffer.from(\"TG\");\n    txn.txGroupHashes = [];\n\n    for (let hash of txgroupForEnc.txlist) {\n      txn.txGroupHashes.push(new Buffer.from(hash));\n    }\n\n    return txn;\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n}\n/**\n * computeGroupID returns group ID for a group of transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @return Buffer\n */\n\n\nfunction computeGroupID(txns) {\n  const hashes = [];\n\n  for (let txn of txns) {\n    let tx = txn;\n\n    if (!(txn instanceof txnBuilder.Transaction)) {\n      tx = new txnBuilder.Transaction(txn);\n    }\n\n    hashes.push(tx.rawTxID());\n  }\n\n  const txgroup = new TxGroup(hashes);\n  const bytes = txgroup.toByte();\n  const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));\n  const gid = nacl.genericHash(toBeHashed);\n  return Buffer.from(gid);\n}\n/**\n * assignGroupID assigns group id to a given list of unsigned transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @param from optional sender address specifying which transaction return\n * @return possible list of matching transactions\n */\n\n\nfunction assignGroupID(txns, from = undefined) {\n  const gid = computeGroupID(txns);\n  let result = [];\n\n  for (let txn of txns) {\n    if (!from || address.encodeAddress(txn.from.publicKey) == from) {\n      let tx = txn;\n\n      if (!(tx instanceof txnBuilder.Transaction)) {\n        tx = new txnBuilder.Transaction(txn);\n      }\n\n      tx.group = gid;\n      result.push(tx);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  TxGroup,\n  computeGroupID,\n  assignGroupID\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/group.js"],"names":["Buffer","require","txnBuilder","nacl","encoding","address","utils","ALGORAND_MAX_TX_GROUP_SIZE","TxGroup","constructor","hashes","length","errorMsg","toString","Error","name","tag","from","txGroupHashes","get_obj_for_encoding","txgroup","from_obj_for_encoding","txgroupForEnc","txn","Object","create","prototype","hash","txlist","push","toByte","encode","computeGroupID","txns","tx","Transaction","rawTxID","bytes","toBeHashed","concatArrays","gid","genericHash","assignGroupID","undefined","result","encodeAddress","publicKey","group","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,qBAAD,CAApB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,qBAAD,CAAxB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,oBAAD,CAAvB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,eAAD,CAArB;;AAEA,MAAMM,0BAA0B,GAAG,EAAnC;AAEA;AACA;AACA;;AACA,MAAMC,OAAN,CAAc;AACVC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,QAAIA,MAAM,CAACC,MAAP,GAAgBJ,0BAApB,EAAgD;AAC5C,UAAIK,QAAQ,GAAGF,MAAM,CAACC,MAAP,CAAcE,QAAd,KAA2B,uDAA3B,GAAqFN,0BAA0B,CAACM,QAA3B,EAApG;AACA,YAAMC,KAAK,CAACF,QAAD,CAAX;AACH;;AAED,SAAKG,IAAL,GAAY,mBAAZ;AACA,SAAKC,GAAL,GAAWhB,MAAM,CAACiB,IAAP,CAAY,IAAZ,CAAX;AAEA,SAAKC,aAAL,GAAqBR,MAArB;AACH;;AAEDS,EAAAA,oBAAoB,GAAG;AACnB,UAAMC,OAAO,GAAG;AACZ,gBAAU,KAAKF;AADH,KAAhB;AAGA,WAAOE,OAAP;AACH;;AAED,SAAOC,qBAAP,CAA6BC,aAA7B,EAA4C;AACxC,UAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAc,KAAKC,SAAnB,CAAZ;AACAH,IAAAA,GAAG,CAACR,IAAJ,GAAW,mBAAX;AACAQ,IAAAA,GAAG,CAACP,GAAJ,GAAUhB,MAAM,CAACiB,IAAP,CAAY,IAAZ,CAAV;AACAM,IAAAA,GAAG,CAACL,aAAJ,GAAoB,EAApB;;AACA,SAAK,IAAIS,IAAT,IAAiBL,aAAa,CAACM,MAA/B,EAAuC;AACnCL,MAAAA,GAAG,CAACL,aAAJ,CAAkBW,IAAlB,CAAuB,IAAI7B,MAAM,CAACiB,IAAX,CAAgBU,IAAhB,CAAvB;AACH;;AACD,WAAOJ,GAAP;AACH;;AAEDO,EAAAA,MAAM,GAAG;AACL,WAAO1B,QAAQ,CAAC2B,MAAT,CAAgB,KAAKZ,oBAAL,EAAhB,CAAP;AACH;;AAjCS;AAqCd;AACA;AACA;AACA;AACA;;;AACA,SAASa,cAAT,CAAwBC,IAAxB,EAA8B;AAC1B,QAAMvB,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIa,GAAT,IAAgBU,IAAhB,EAAsB;AAClB,QAAIC,EAAE,GAAGX,GAAT;;AACA,QAAI,EAAEA,GAAG,YAAYrB,UAAU,CAACiC,WAA5B,CAAJ,EAA8C;AAC1CD,MAAAA,EAAE,GAAG,IAAIhC,UAAU,CAACiC,WAAf,CAA2BZ,GAA3B,CAAL;AACH;;AACDb,IAAAA,MAAM,CAACmB,IAAP,CAAYK,EAAE,CAACE,OAAH,EAAZ;AACH;;AAED,QAAMhB,OAAO,GAAG,IAAIZ,OAAJ,CAAYE,MAAZ,CAAhB;AAEA,QAAM2B,KAAK,GAAGjB,OAAO,CAACU,MAAR,EAAd;AACA,QAAMQ,UAAU,GAAGtC,MAAM,CAACiB,IAAP,CAAYX,KAAK,CAACiC,YAAN,CAAmBnB,OAAO,CAACJ,GAA3B,EAAgCqB,KAAhC,CAAZ,CAAnB;AACA,QAAMG,GAAG,GAAGrC,IAAI,CAACsC,WAAL,CAAiBH,UAAjB,CAAZ;AACA,SAAOtC,MAAM,CAACiB,IAAP,CAAYuB,GAAZ,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,aAAT,CAAuBT,IAAvB,EAA6BhB,IAAI,GAAG0B,SAApC,EAA+C;AAC3C,QAAMH,GAAG,GAAGR,cAAc,CAACC,IAAD,CAA1B;AACA,MAAIW,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIrB,GAAT,IAAgBU,IAAhB,EAAsB;AAClB,QAAI,CAAChB,IAAD,IAASZ,OAAO,CAACwC,aAAR,CAAsBtB,GAAG,CAACN,IAAJ,CAAS6B,SAA/B,KAA6C7B,IAA1D,EAAgE;AAC5D,UAAIiB,EAAE,GAAGX,GAAT;;AACA,UAAI,EAAEW,EAAE,YAAYhC,UAAU,CAACiC,WAA3B,CAAJ,EAA6C;AACzCD,QAAAA,EAAE,GAAG,IAAIhC,UAAU,CAACiC,WAAf,CAA2BZ,GAA3B,CAAL;AACH;;AACDW,MAAAA,EAAE,CAACa,KAAH,GAAWP,GAAX;AACAI,MAAAA,MAAM,CAACf,IAAP,CAAYK,EAAZ;AACH;AACJ;;AACD,SAAOU,MAAP;AACH;;AAEDI,MAAM,CAACC,OAAP,GAAiB;AACbzC,EAAAA,OADa;AAEbwB,EAAAA,cAFa;AAGbU,EAAAA;AAHa,CAAjB","sourcesContent":["const { Buffer } = require(\"buffer\");\nconst txnBuilder = require('./transaction');\nconst nacl = require('./nacl/naclWrappers');\nconst encoding = require('./encoding/encoding');\nconst address = require('./encoding/address');\nconst utils = require('./utils/utils');\n\nconst ALGORAND_MAX_TX_GROUP_SIZE = 16;\n\n/**\n * Aux class for group id calculation of a group of transactions\n */\nclass TxGroup {\n    constructor(hashes) {\n        if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {\n            let errorMsg = hashes.length.toString() + \" transactions grouped together but max group size is \" + ALGORAND_MAX_TX_GROUP_SIZE.toString();\n            throw Error(errorMsg);\n        }\n\n        this.name = \"Transaction group\";\n        this.tag = Buffer.from(\"TG\");\n\n        this.txGroupHashes = hashes;\n    }\n\n    get_obj_for_encoding() {\n        const txgroup = {\n            \"txlist\": this.txGroupHashes\n        };\n        return txgroup;\n    }\n\n    static from_obj_for_encoding(txgroupForEnc) {\n        const txn = Object.create(this.prototype);\n        txn.name = \"Transaction group\";\n        txn.tag = Buffer.from(\"TG\");\n        txn.txGroupHashes = [];\n        for (let hash of txgroupForEnc.txlist) {\n            txn.txGroupHashes.push(new Buffer.from(hash));\n        }\n        return txn;\n    }\n\n    toByte() {\n        return encoding.encode(this.get_obj_for_encoding());\n    }\n\n}\n\n/**\n * computeGroupID returns group ID for a group of transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @return Buffer\n */\nfunction computeGroupID(txns) {\n    const hashes = [];\n    for (let txn of txns) {\n        let tx = txn;\n        if (!(txn instanceof txnBuilder.Transaction)) {\n            tx = new txnBuilder.Transaction(txn);\n        }\n        hashes.push(tx.rawTxID());\n    }\n\n    const txgroup = new TxGroup(hashes);\n\n    const bytes = txgroup.toByte();\n    const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));\n    const gid = nacl.genericHash(toBeHashed)\n    return Buffer.from(gid);\n}\n\n/**\n * assignGroupID assigns group id to a given list of unsigned transactions\n * @param txns array of transactions (every element is a dict or Transaction)\n * @param from optional sender address specifying which transaction return\n * @return possible list of matching transactions\n */\nfunction assignGroupID(txns, from = undefined) {\n    const gid = computeGroupID(txns);\n    let result = [];\n    for (let txn of txns) {\n        if (!from || address.encodeAddress(txn.from.publicKey) == from) {\n            let tx = txn;\n            if (!(tx instanceof txnBuilder.Transaction)) {\n                tx = new txnBuilder.Transaction(txn);\n            }\n            tx.group = gid;\n            result.push(tx);\n        }\n    }\n    return result;\n}\n\nmodule.exports = {\n    TxGroup,\n    computeGroupID,\n    assignGroupID,\n};\n"]},"metadata":{},"sourceType":"script"}