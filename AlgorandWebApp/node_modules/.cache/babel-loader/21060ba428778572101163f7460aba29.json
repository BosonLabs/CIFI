{"ast":null,"code":"const base32 = require('hi-base32');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst utils = require('../utils/utils');\n\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nconst ALGORAND_ZERO_ADDRESS_STRING = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ\"; // Convert \"MultisigAddr\" UTF-8 to byte array\n\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nconst MALFORMED_ADDRESS_ERROR = new Error(\"address seems to be malformed\");\nconst INVALID_MSIG_VERSION = new Error(\"invalid multisig version\");\nconst INVALID_MSIG_THRESHOLD = new Error(\"bad multisig threshold\");\nconst INVALID_MSIG_PK = new Error(\"bad multisig public key - wrong length\");\nconst UNEXPECTED_PK_LEN = new Error(\"nacl public key length is not 32 bytes\");\n/**\n * isValidAddress takes an Algorand address and checks if valid.\n * @param address Algorand address\n * @returns {boolean} true if valid, false otherwise\n */\n\nfunction isValidAddress(address) {\n  if (typeof address !== \"string\") return false;\n  if (address.length !== ALGORAND_ADDRESS_LENGTH) return false; // Try to decode\n\n  let decoded;\n\n  try {\n    decoded = decodeAddress(address);\n  } catch (e) {\n    return false;\n  } // Compute checksum\n\n\n  let checksum = nacl.genericHash(decoded.publicKey).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH); // Check if the checksum and the address are equal\n\n  return utils.arrayEqual(checksum, decoded.checksum);\n}\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param {string} address an Algorand address with checksum.\n * @returns {{publicKey: Uint8Array, checksum: Uint8Array}} the decoded form of the address's public key and checksum\n */\n\n\nfunction decodeAddress(address) {\n  if (!(typeof address === \"string\" || address instanceof String)) throw MALFORMED_ADDRESS_ERROR; //try to decode\n\n  let decoded = base32.decode.asBytes(address); // Sanity check\n\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw MALFORMED_ADDRESS_ERROR;\n  let pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  let cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n  return {\n    \"publicKey\": pk,\n    \"checksum\": cs\n  };\n}\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param {Uint8Array} address a raw Algorand address\n * @returns {string} the address and checksum encoded as a string.\n */\n\n\nfunction encodeAddress(address) {\n  //compute checksum\n  let checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  let addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param pks array of typed array public keys\n */\n\n\nfunction fromMultisigPreImg({\n  version,\n  threshold,\n  pks\n}) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw INVALID_MSIG_VERSION;\n  }\n\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw INVALID_MSIG_THRESHOLD;\n  }\n\n  let pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw UNEXPECTED_PK_LEN;\n  }\n\n  let merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n\n  for (var i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw INVALID_MSIG_PK;\n    }\n\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n\n  return nacl.genericHash(merged);\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs array of encoded addresses\n */\n\n\nfunction fromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs\n}) {\n  const pks = addrs.map(addr => {\n    return decodeAddress(addr).publicKey;\n  });\n  return encodeAddress(fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  }));\n}\n\nmodule.exports = {\n  isValidAddress,\n  decodeAddress,\n  encodeAddress,\n  fromMultisigPreImg,\n  fromMultisigPreImgAddrs,\n  MALFORMED_ADDRESS_ERROR,\n  INVALID_MSIG_VERSION,\n  INVALID_MSIG_THRESHOLD,\n  INVALID_MSIG_PK,\n  UNEXPECTED_PK_LEN,\n  ALGORAND_ZERO_ADDRESS_STRING\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/encoding/address.js"],"names":["base32","require","nacl","utils","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","MALFORMED_ADDRESS_ERROR","Error","INVALID_MSIG_VERSION","INVALID_MSIG_THRESHOLD","INVALID_MSIG_PK","UNEXPECTED_PK_LEN","isValidAddress","address","length","decoded","decodeAddress","e","checksum","genericHash","publicKey","slice","HASH_BYTES_LENGTH","arrayEqual","String","decode","asBytes","pk","cs","PUBLIC_KEY_LENGTH","encodeAddress","addr","encode","concatArrays","toString","fromMultisigPreImg","version","threshold","pks","pkLen","merged","set","i","fromMultisigPreImgAddrs","addrs","map","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,sBAAD,CAApB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,gBAAD,CAArB;;AAEA,MAAMG,4BAA4B,GAAG,EAArC;AACA,MAAMC,6BAA6B,GAAG,CAAtC;AACA,MAAMC,uBAAuB,GAAG,EAAhC;AACA,MAAMC,4BAA4B,GAAG,4DAArC,C,CAEA;;AACA,MAAMC,2BAA2B,GAAG,IAAIC,UAAJ,CAAe,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC,GAAnC,EAAwC,EAAxC,EAA4C,GAA5C,EAAiD,GAAjD,EAAsD,GAAtD,CAAf,CAApC;AAEA,MAAMC,uBAAuB,GAAG,IAAIC,KAAJ,CAAU,+BAAV,CAAhC;AACA,MAAMC,oBAAoB,GAAG,IAAID,KAAJ,CAAU,0BAAV,CAA7B;AACA,MAAME,sBAAsB,GAAG,IAAIF,KAAJ,CAAU,wBAAV,CAA/B;AACA,MAAMG,eAAe,GAAG,IAAIH,KAAJ,CAAU,wCAAV,CAAxB;AACA,MAAMI,iBAAiB,GAAG,IAAIJ,KAAJ,CAAU,wCAAV,CAA1B;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASK,cAAT,CAAwBC,OAAxB,EAAiC;AAC7B,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC,OAAO,KAAP;AAEjC,MAAIA,OAAO,CAACC,MAAR,KAAmBZ,uBAAvB,EAAgD,OAAO,KAAP,CAHnB,CAK7B;;AACA,MAAIa,OAAJ;;AACA,MAAI;AACAA,IAAAA,OAAO,GAAGC,aAAa,CAACH,OAAD,CAAvB;AACH,GAFD,CAEE,OAAOI,CAAP,EAAU;AACR,WAAO,KAAP;AACH,GAX4B,CAa7B;;;AACA,MAAIC,QAAQ,GAAGpB,IAAI,CAACqB,WAAL,CAAiBJ,OAAO,CAACK,SAAzB,EAAoCC,KAApC,CAA0CvB,IAAI,CAACwB,iBAAL,GAAyBrB,6BAAnE,EAAiGH,IAAI,CAACwB,iBAAtG,CAAf,CAd6B,CAgB7B;;AACA,SAAOvB,KAAK,CAACwB,UAAN,CAAiBL,QAAjB,EAA2BH,OAAO,CAACG,QAAnC,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASF,aAAT,CAAuBH,OAAvB,EAAgC;AAC5B,MAAI,EAAE,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,YAAYW,MAApD,CAAJ,EAAiE,MAAMlB,uBAAN,CADrC,CAG5B;;AACA,MAAIS,OAAO,GAAGnB,MAAM,CAAC6B,MAAP,CAAcC,OAAd,CAAsBb,OAAtB,CAAd,CAJ4B,CAM5B;;AACA,MAAIE,OAAO,CAACD,MAAR,KAAmBd,4BAAvB,EAAqD,MAAMM,uBAAN;AAErD,MAAIqB,EAAE,GAAG,IAAItB,UAAJ,CAAeU,OAAO,CAACM,KAAR,CAAc,CAAd,EAAiBrB,4BAA4B,GAAGC,6BAAhD,CAAf,CAAT;AACA,MAAI2B,EAAE,GAAG,IAAIvB,UAAJ,CAAeU,OAAO,CAACM,KAAR,CAAcvB,IAAI,CAAC+B,iBAAnB,EAAsC7B,4BAAtC,CAAf,CAAT;AAEA,SAAO;AAAC,iBAAa2B,EAAd;AAAkB,gBAAYC;AAA9B,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,aAAT,CAAuBjB,OAAvB,EAAgC;AAC5B;AACA,MAAIK,QAAQ,GAAGpB,IAAI,CAACqB,WAAL,CAAiBN,OAAjB,EAA0BQ,KAA1B,CAAgCvB,IAAI,CAAC+B,iBAAL,GAAyB5B,6BAAzD,EAAwFH,IAAI,CAAC+B,iBAA7F,CAAf;AACA,MAAIE,IAAI,GAAGnC,MAAM,CAACoC,MAAP,CAAcjC,KAAK,CAACkC,YAAN,CAAmBpB,OAAnB,EAA4BK,QAA5B,CAAd,CAAX;AAEA,SAAOa,IAAI,CAACG,QAAL,GAAgBb,KAAhB,CAAsB,CAAtB,EAAyBnB,uBAAzB,CAAP,CAL4B,CAK8B;AAC7D;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiC,kBAAT,CAA4B;AAACC,EAAAA,OAAD;AAAUC,EAAAA,SAAV;AAAqBC,EAAAA;AAArB,CAA5B,EAAuD;AACnD,MAAIF,OAAO,KAAK,CAAZ,IAAiBA,OAAO,GAAG,GAA3B,IAAkCA,OAAO,GAAG,CAAhD,EAAmD;AAC/C;AACA,UAAM5B,oBAAN;AACH;;AACD,MAAI6B,SAAS,KAAK,CAAd,IAAmBC,GAAG,CAACxB,MAAJ,KAAe,CAAlC,IAAuCuB,SAAS,GAAGC,GAAG,CAACxB,MAAvD,IAAiEuB,SAAS,GAAG,GAAjF,EAAsF;AAClF,UAAM5B,sBAAN;AACH;;AACD,MAAI8B,KAAK,GAAGvC,4BAA4B,GAAGC,6BAA3C;;AACA,MAAIsC,KAAK,KAAKzC,IAAI,CAAC+B,iBAAnB,EAAsC;AAClC,UAAMlB,iBAAN;AACH;;AACD,MAAI6B,MAAM,GAAG,IAAInC,UAAJ,CAAeD,2BAA2B,CAACU,MAA5B,GAAqC,CAArC,GAAyCyB,KAAK,GAACD,GAAG,CAACxB,MAAlE,CAAb;AACA0B,EAAAA,MAAM,CAACC,GAAP,CAAWrC,2BAAX,EAAwC,CAAxC;AACAoC,EAAAA,MAAM,CAACC,GAAP,CAAW,CAACL,OAAD,CAAX,EAAsBhC,2BAA2B,CAACU,MAAlD;AACA0B,EAAAA,MAAM,CAACC,GAAP,CAAW,CAACJ,SAAD,CAAX,EAAwBjC,2BAA2B,CAACU,MAA5B,GAAqC,CAA7D;;AACA,OAAK,IAAI4B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,GAAG,CAACxB,MAAxB,EAAgC4B,CAAC,EAAjC,EAAqC;AACjC,QAAIJ,GAAG,CAACI,CAAD,CAAH,CAAO5B,MAAP,KAAkByB,KAAtB,EAA6B;AACzB,YAAM7B,eAAN;AACH;;AACD8B,IAAAA,MAAM,CAACC,GAAP,CAAWH,GAAG,CAACI,CAAD,CAAd,EAAmBtC,2BAA2B,CAACU,MAA5B,GAAqC,CAArC,GAAyC4B,CAAC,GAACH,KAA9D;AACH;;AACD,SAAOzC,IAAI,CAACqB,WAAL,CAAiBqB,MAAjB,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,uBAAT,CAAiC;AAACP,EAAAA,OAAD;AAAUC,EAAAA,SAAV;AAAqBO,EAAAA;AAArB,CAAjC,EAA8D;AAC1D,QAAMN,GAAG,GAAGM,KAAK,CAACC,GAAN,CAAUd,IAAI,IAAI;AAC1B,WAAOf,aAAa,CAACe,IAAD,CAAb,CAAoBX,SAA3B;AACH,GAFW,CAAZ;AAGA,SAAOU,aAAa,CAACK,kBAAkB,CAAC;AAACC,IAAAA,OAAD;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA;AAArB,GAAD,CAAnB,CAApB;AACH;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACbnC,EAAAA,cADa;AAEbI,EAAAA,aAFa;AAGbc,EAAAA,aAHa;AAIbK,EAAAA,kBAJa;AAKbQ,EAAAA,uBALa;AAMbrC,EAAAA,uBANa;AAObE,EAAAA,oBAPa;AAQbC,EAAAA,sBARa;AASbC,EAAAA,eATa;AAUbC,EAAAA,iBAVa;AAWbR,EAAAA;AAXa,CAAjB","sourcesContent":["const base32 = require('hi-base32');\nconst nacl = require('../nacl/naclWrappers');\nconst utils = require('../utils/utils');\n\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nconst ALGORAND_ZERO_ADDRESS_STRING = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ\";\n\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\n\nconst MALFORMED_ADDRESS_ERROR = new Error(\"address seems to be malformed\");\nconst INVALID_MSIG_VERSION = new Error(\"invalid multisig version\");\nconst INVALID_MSIG_THRESHOLD = new Error(\"bad multisig threshold\");\nconst INVALID_MSIG_PK = new Error(\"bad multisig public key - wrong length\");\nconst UNEXPECTED_PK_LEN = new Error(\"nacl public key length is not 32 bytes\");\n\n/**\n * isValidAddress takes an Algorand address and checks if valid.\n * @param address Algorand address\n * @returns {boolean} true if valid, false otherwise\n */\nfunction isValidAddress(address) {\n    if (typeof address !== \"string\") return false;\n\n    if (address.length !== ALGORAND_ADDRESS_LENGTH) return false;\n\n    // Try to decode\n    let decoded;\n    try {\n        decoded = decodeAddress(address);\n    } catch (e) {\n        return false;\n    }\n\n    // Compute checksum\n    let checksum = nacl.genericHash(decoded.publicKey).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,nacl.HASH_BYTES_LENGTH);\n\n    // Check if the checksum and the address are equal\n    return utils.arrayEqual(checksum, decoded.checksum);\n}\n\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param {string} address an Algorand address with checksum.\n * @returns {{publicKey: Uint8Array, checksum: Uint8Array}} the decoded form of the address's public key and checksum\n */\nfunction decodeAddress(address) {\n    if (!(typeof address === \"string\" || address instanceof String)) throw MALFORMED_ADDRESS_ERROR;\n\n    //try to decode\n    let decoded = base32.decode.asBytes(address);\n\n    // Sanity check\n    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw MALFORMED_ADDRESS_ERROR;\n\n    let pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n    let cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n\n    return {\"publicKey\": pk, \"checksum\": cs}\n}\n\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param {Uint8Array} address a raw Algorand address\n * @returns {string} the address and checksum encoded as a string.\n */\nfunction encodeAddress(address) {\n    //compute checksum\n    let checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n    let addr = base32.encode(utils.concatArrays(address, checksum));\n\n    return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param pks array of typed array public keys\n */\nfunction fromMultisigPreImg({version, threshold, pks}) {\n    if (version !== 1 || version > 255 || version < 0) {\n        // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n        throw INVALID_MSIG_VERSION;\n    }\n    if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n        throw INVALID_MSIG_THRESHOLD;\n    }\n    let pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n    if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n        throw UNEXPECTED_PK_LEN;\n    }\n    let merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen*pks.length);\n    merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n    merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n    merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n    for (var i = 0; i < pks.length; i++) {\n        if (pks[i].length !== pkLen) {\n            throw INVALID_MSIG_PK;\n        }\n        merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i*pkLen);\n    }\n    return nacl.genericHash(merged);\n}\n\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs array of encoded addresses\n */\nfunction fromMultisigPreImgAddrs({version, threshold, addrs}) {\n    const pks = addrs.map(addr => {\n        return decodeAddress(addr).publicKey;\n    });\n    return encodeAddress(fromMultisigPreImg({version, threshold, pks}));\n}\n\nmodule.exports = {\n    isValidAddress,\n    decodeAddress,\n    encodeAddress,\n    fromMultisigPreImg,\n    fromMultisigPreImgAddrs,\n    MALFORMED_ADDRESS_ERROR,\n    INVALID_MSIG_VERSION,\n    INVALID_MSIG_THRESHOLD,\n    INVALID_MSIG_PK,\n    UNEXPECTED_PK_LEN,\n    ALGORAND_ZERO_ADDRESS_STRING\n};\n"]},"metadata":{},"sourceType":"script"}