{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst encoding = require('../encoding/encoding');\n\nconst group = require('../group');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst templates = require('./templates');\n\nconst transaction = require('../transaction');\n\nclass DynamicFee {\n  /**\n   * DynamicFee contract allows you to create a transaction without\n   * specifying the fee. The fee will be determined at the moment of\n   * transfer.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address to receive the assets\n   * @param {int} amount: amount of assets to transfer\n   * @param {int} firstValid: first valid round for the transaction\n   * @param {int} lastValid:  last valid round for the transaction\n   * @param {string} closeRemainder: if you would like to close the account after the transfer, specify the address that would recieve the remainder, else leave undefined\n   * @param {string} lease: leave undefined to generate a random lease, or supply a lease as base64\n   * @returns {DynamicFee}\n   */\n  constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {\n    // don't need to validate receiver, closeremainderto - insert will handle that\n    if (!Number.isSafeInteger(amount) || amount < 0) throw Error(\"amount must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(firstValid) || firstValid < 0) throw Error(\"firstValid must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(lastValid) || lastValid < 0) throw Error(\"lastValid must be a positive number and smaller than 2^53-1\");\n\n    if (closeRemainder === undefined) {\n      closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;\n    }\n\n    if (lease === undefined) {\n      let leaseBytes = nacl.randomBytes(32);\n      lease = Buffer.from(leaseBytes).toString('base64');\n    }\n\n    const referenceProgramB64 = \"ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ\";\n    let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    let referenceOffsets = [\n    /*amount*/\n    5\n    /*firstValid*/\n    , 6\n    /*lastValid*/\n    , 7\n    /*receiver*/\n    , 11\n    /*closeRemainder*/\n    , 44\n    /*lease*/\n    , 76];\n    let injectionVector = [amount, firstValid, lastValid, receiver, closeRemainder, lease];\n    let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.BASE64];\n    let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * signDynamicFee returns the main transaction and signed logic needed to complete the transfer.\n * These should be sent to the fee payer, who can use GetDynamicFeeTransactions\n * @param {Uint8Array} contract: the bytearray representing the contract\n * @param {Uint8Array} secretKey: the secret key for building the logic sig\n * @param {string} genesisHash: the genesisHash to use for the txn\n * @returns {Object} object containing json of txnbuilder constructor arguments under \"txn\" and signed logicsig under \"lsig\"\n */\n\n\nfunction signDynamicFee(contract, secretKey, genesisHash) {\n  let programOutputs = logic.readProgram(contract, undefined);\n  let ints = programOutputs[0];\n  let byteArrays = programOutputs[1];\n  let keys = nacl.keyPairFromSecretKey(secretKey);\n  let from = address.encodeAddress(keys.publicKey);\n  let to = address.encodeAddress(byteArrays[0]);\n  let fee = 0;\n  let amount = ints[2];\n  let closeRemainderTo = address.encodeAddress(byteArrays[1]);\n  let firstRound = ints[3];\n  let lastRound = ints[4];\n  let lease = new Uint8Array(byteArrays[2]);\n  let txn = {\n    \"from\": from,\n    \"to\": to,\n    \"fee\": fee,\n    \"amount\": amount,\n    \"closeRemainderTo\": closeRemainderTo,\n    \"firstRound\": firstRound,\n    \"lastRound\": lastRound,\n    \"genesisHash\": genesisHash,\n    \"type\": \"pay\",\n    \"lease\": lease\n  };\n  let lsig = new logicSig.LogicSig(contract, undefined);\n  lsig.sign(secretKey);\n  return {\n    \"txn\": txn,\n    \"lsig\": lsig\n  };\n}\n/**\n * getDynamicFeeTransactions creates and signs the secondary dynamic fee transaction, updates\n * transaction fields, and signs as the fee payer; it returns both\n * transactions as bytes suitable for sendRaw.\n * Parameters:\n * @param {dict} txn - main transaction from payer's signDynamicFee output (a dict of constructor arguments, NOT a transaction.Transaction)\n * @param {LogicSig} lsig - the signed logic received from the payer's signDynamicFee output\n * @param {Uint8Array} privateKey - the private key for the account that pays the fee\n * @param {int} fee - fee per byte for both transactions\n *\n * @throws on invalid lsig\n */\n\n\nfunction getDynamicFeeTransactions(txn, lsig, privateKey, fee) {\n  if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n    throw new Error(\"invalid signature\");\n  }\n\n  txn.fee = fee;\n\n  if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {\n    txn.fee = transaction.ALGORAND_MIN_TX_FEE;\n  }\n\n  let keys = nacl.keyPairFromSecretKey(privateKey);\n  let from = address.encodeAddress(keys.publicKey); // must remove lease and re-add using addLease so that fee calculation will match other SDKs\n\n  let lease = txn.lease;\n  delete txn.lease;\n  let txnObj = new transaction.Transaction(txn);\n  txnObj.addLease(lease, fee);\n  let feePayTxn = {\n    \"from\": from,\n    \"to\": txn.from,\n    \"fee\": fee,\n    \"amount\": txnObj.fee,\n    // calculated after txnObj is built to have the correct fee\n    \"firstRound\": txn.firstRound,\n    \"lastRound\": txn.lastRound,\n    \"genesisHash\": txn.genesisHash,\n    \"type\": \"pay\"\n  };\n  let feePayTxnObj = new transaction.Transaction(feePayTxn);\n  feePayTxnObj.addLease(lease, fee);\n  let txnGroup = group.assignGroupID([feePayTxnObj, txnObj], undefined);\n  let feePayTxnWithGroup = txnGroup[0];\n  let txnObjWithGroup = txnGroup[1];\n  let lstx = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txnObjWithGroup.get_obj_for_encoding()\n  };\n  let stx1 = feePayTxnWithGroup.signTxn(privateKey);\n  let stx2 = encoding.encode(lstx);\n  let concatStx = new Uint8Array(stx1.length + stx2.length);\n  concatStx.set(stx1);\n  concatStx.set(stx2, stx1.length);\n  return concatStx;\n}\n\nmodule.exports = {\n  DynamicFee,\n  getDynamicFeeTransactions,\n  signDynamicFee\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/dynamicfee.js"],"names":["Buffer","require","address","encoding","group","logic","logicSig","nacl","templates","transaction","DynamicFee","constructor","receiver","amount","firstValid","lastValid","closeRemainder","lease","Number","isSafeInteger","Error","undefined","ALGORAND_ZERO_ADDRESS_STRING","leaseBytes","randomBytes","from","toString","referenceProgramB64","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","BASE64","injectedBytes","inject","programBytes","lsig","LogicSig","getProgram","getAddress","signDynamicFee","contract","secretKey","genesisHash","programOutputs","readProgram","ints","byteArrays","keys","keyPairFromSecretKey","encodeAddress","publicKey","to","fee","closeRemainderTo","firstRound","lastRound","Uint8Array","txn","sign","getDynamicFeeTransactions","privateKey","verify","decodeAddress","ALGORAND_MIN_TX_FEE","txnObj","Transaction","addLease","feePayTxn","feePayTxnObj","txnGroup","assignGroupID","feePayTxnWithGroup","txnObjWithGroup","lstx","get_obj_for_encoding","stx1","signTxn","stx2","encode","concatStx","length","set","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst encoding = require('../encoding/encoding');\nconst group = require('../group');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\nconst transaction = require('../transaction');\n\nclass DynamicFee {\n    /**\n     * DynamicFee contract allows you to create a transaction without\n     * specifying the fee. The fee will be determined at the moment of\n     * transfer.\n     *\n     * Constructor Parameters:\n     * @param {string} receiver: address to receive the assets\n     * @param {int} amount: amount of assets to transfer\n     * @param {int} firstValid: first valid round for the transaction\n     * @param {int} lastValid:  last valid round for the transaction\n     * @param {string} closeRemainder: if you would like to close the account after the transfer, specify the address that would recieve the remainder, else leave undefined\n     * @param {string} lease: leave undefined to generate a random lease, or supply a lease as base64\n     * @returns {DynamicFee}\n     */\n    constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {\n        // don't need to validate receiver, closeremainderto - insert will handle that\n        if (!Number.isSafeInteger(amount) || amount < 0) throw Error(\"amount must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(firstValid) || firstValid < 0) throw Error(\"firstValid must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(lastValid) || lastValid < 0) throw Error(\"lastValid must be a positive number and smaller than 2^53-1\");\n\n        if (closeRemainder === undefined) {\n            closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;\n        }\n        if (lease === undefined) {\n            let leaseBytes = nacl.randomBytes(32);\n            lease = Buffer.from(leaseBytes).toString('base64');\n        }\n\n        const referenceProgramB64 = \"ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ\";\n        let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n        let referenceOffsets = [ /*amount*/ 5 /*firstValid*/, 6 /*lastValid*/, 7 /*receiver*/, 11 /*closeRemainder*/, 44 /*lease*/, 76];\n        let injectionVector =  [amount, firstValid, lastValid, receiver, closeRemainder, lease];\n        let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT,\n            templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.BASE64];\n        let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n        this.programBytes = injectedBytes;\n        let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n        this.address = lsig.address();\n    }\n\n    /**\n     * returns the program bytes\n     * @returns {Uint8Array}\n     */\n    getProgram() {\n        return this.programBytes;\n    }\n\n    /**\n     * returns the string address of the contract\n     * @returns {string}\n     */\n    getAddress() {\n        return this.address;\n    }\n\n}\n/**\n * signDynamicFee returns the main transaction and signed logic needed to complete the transfer.\n * These should be sent to the fee payer, who can use GetDynamicFeeTransactions\n * @param {Uint8Array} contract: the bytearray representing the contract\n * @param {Uint8Array} secretKey: the secret key for building the logic sig\n * @param {string} genesisHash: the genesisHash to use for the txn\n * @returns {Object} object containing json of txnbuilder constructor arguments under \"txn\" and signed logicsig under \"lsig\"\n */\nfunction signDynamicFee(contract, secretKey, genesisHash) {\n    let programOutputs = logic.readProgram(contract, undefined);\n    let ints = programOutputs[0];\n    let byteArrays = programOutputs[1];\n    let keys = nacl.keyPairFromSecretKey(secretKey);\n    let from = address.encodeAddress(keys.publicKey);\n    let to = address.encodeAddress(byteArrays[0]);\n    let fee = 0;\n    let amount = ints[2];\n    let closeRemainderTo = address.encodeAddress(byteArrays[1]);\n    let firstRound = ints[3];\n    let lastRound = ints[4];\n    let lease = new Uint8Array(byteArrays[2]);\n    let txn = {\n        \"from\": from,\n        \"to\": to,\n        \"fee\": fee,\n        \"amount\": amount,\n        \"closeRemainderTo\": closeRemainderTo,\n        \"firstRound\": firstRound,\n        \"lastRound\": lastRound,\n        \"genesisHash\": genesisHash,\n        \"type\": \"pay\",\n        \"lease\": lease\n    };\n\n    let lsig = new logicSig.LogicSig(contract, undefined);\n    lsig.sign(secretKey);\n    return {\"txn\": txn, \"lsig\": lsig};\n}\n\n/**\n * getDynamicFeeTransactions creates and signs the secondary dynamic fee transaction, updates\n * transaction fields, and signs as the fee payer; it returns both\n * transactions as bytes suitable for sendRaw.\n * Parameters:\n * @param {dict} txn - main transaction from payer's signDynamicFee output (a dict of constructor arguments, NOT a transaction.Transaction)\n * @param {LogicSig} lsig - the signed logic received from the payer's signDynamicFee output\n * @param {Uint8Array} privateKey - the private key for the account that pays the fee\n * @param {int} fee - fee per byte for both transactions\n *\n * @throws on invalid lsig\n */\nfunction getDynamicFeeTransactions (txn, lsig, privateKey, fee) {\n    if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {\n        throw new Error(\"invalid signature\");\n    }\n\n    txn.fee = fee;\n    if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {\n        txn.fee = transaction.ALGORAND_MIN_TX_FEE\n    }\n\n    let keys = nacl.keyPairFromSecretKey(privateKey);\n    let from = address.encodeAddress(keys.publicKey);\n\n    // must remove lease and re-add using addLease so that fee calculation will match other SDKs\n    let lease = txn.lease;\n    delete txn.lease;\n\n    let txnObj = new transaction.Transaction(txn);\n    txnObj.addLease(lease, fee);\n\n    let feePayTxn = {\n        \"from\": from,\n        \"to\": txn.from,\n        \"fee\": fee,\n        \"amount\": txnObj.fee, // calculated after txnObj is built to have the correct fee\n        \"firstRound\": txn.firstRound,\n        \"lastRound\": txn.lastRound,\n        \"genesisHash\": txn.genesisHash,\n        \"type\": \"pay\"\n    };\n    let feePayTxnObj = new transaction.Transaction(feePayTxn);\n    feePayTxnObj.addLease(lease, fee);\n\n    let txnGroup = group.assignGroupID([feePayTxnObj, txnObj], undefined);\n    let feePayTxnWithGroup = txnGroup[0];\n    let txnObjWithGroup = txnGroup[1];\n\n    let lstx = {\n        lsig: lsig.get_obj_for_encoding(),\n        txn: txnObjWithGroup.get_obj_for_encoding()\n    };\n\n    let stx1 = feePayTxnWithGroup.signTxn(privateKey);\n    let stx2 = encoding.encode(lstx);\n\n    let concatStx = new Uint8Array(stx1.length + stx2.length);\n    concatStx.set(stx1);\n    concatStx.set(stx2, stx1.length);\n\n    return concatStx\n}\n\nmodule.exports = {\n    DynamicFee,\n    getDynamicFeeTransactions,\n    signDynamicFee\n};\n"]},"metadata":{},"sourceType":"script"}