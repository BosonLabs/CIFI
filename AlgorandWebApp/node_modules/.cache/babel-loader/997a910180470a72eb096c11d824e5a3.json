{"ast":null,"code":"const {\n  Buffer\n} = require(\"buffer\");\n\nconst request = require(\"superagent\");\n/**\n * removeEmpty gets a dictionary and removes empty values\n * @param obj\n * @returns {*}\n */\n\n\nfunction removeEmpty(obj) {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n\n  return obj;\n}\n/**\n * getAccceptFormat returns the correct Accept header depending on the\n * requested format.\n * @param query\n * @returns {string}\n */\n\n\nfunction getAccceptFormat(query) {\n  if (query !== undefined && query.hasOwnProperty('format')) switch (query.format) {\n    case 'msgpack':\n      return 'application/msgpack';\n\n    case 'json':\n      return 'application/json';\n\n    default:\n      return 'application/json';\n  } else return \"application/json\";\n}\n\nfunction HTTPClient(token, baseServer, port, headers = {}) {\n  // Do not need colon if port is empty\n  if (port !== '') {\n    baseServer += \":\" + port.toString();\n  }\n\n  this.address = baseServer;\n  this.token = token;\n  this.defaultHeaders = headers;\n\n  this.get = async function (path, query, requestHeaders = {}) {\n    try {\n      const format = getAccceptFormat(query);\n      let r = request.get(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).set('Accept', format).query(removeEmpty(query));\n\n      if (format === 'application/msgpack') {\n        r = r.responseType('arraybuffer');\n      }\n\n      const res = await r;\n\n      if (Buffer.isBuffer(res.body)) {\n        // In node res.body will be a Buffer, but in the browser it will be an ArrayBuffer\n        // (thanks superagent...), so convert it to an ArrayBuffer for consistency.\n        const underlyingArrayBuffer = res.body.buffer;\n        const start = res.body.byteOffset;\n        const end = start + res.body.byteLength;\n        res.body = underlyingArrayBuffer.slice(start, end);\n      }\n\n      return res;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  this.post = async function (path, data, requestHeaders = {}) {\n    try {\n      return await request.post(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).send(data);\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  this.delete = async function (path, data, requestHeaders = {}) {\n    try {\n      return await request.delete(this.address + path).set(this.token).set(this.defaultHeaders).set(requestHeaders).send(data);\n    } catch (e) {\n      throw e;\n    }\n  };\n}\n\nmodule.exports = {\n  HTTPClient\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/client/client.js"],"names":["Buffer","require","request","removeEmpty","obj","key","hasOwnProperty","length","getAccceptFormat","query","undefined","format","HTTPClient","token","baseServer","port","headers","toString","address","defaultHeaders","get","path","requestHeaders","r","set","responseType","res","isBuffer","body","underlyingArrayBuffer","buffer","start","byteOffset","end","byteLength","slice","e","post","data","send","delete","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require(\"buffer\");\nconst request = require(\"superagent\");\n\n/**\n * removeEmpty gets a dictionary and removes empty values\n * @param obj\n * @returns {*}\n */\nfunction removeEmpty(obj) {\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            if (!obj[key] || obj[key].length === 0) delete obj[key];\n        }\n    }\n    return obj;\n}\n\n/**\n * getAccceptFormat returns the correct Accept header depending on the\n * requested format.\n * @param query\n * @returns {string}\n */\nfunction getAccceptFormat(query) {\n    if (query !== undefined && query.hasOwnProperty('format'))\n        switch(query.format) {\n            case 'msgpack':\n                return 'application/msgpack';\n            case 'json':\n                return 'application/json';\n            default:\n                return 'application/json';\n        }\n    else\n        return \"application/json\"\n }\n\nfunction HTTPClient(token, baseServer, port, headers={}) {\n    // Do not need colon if port is empty\n    if (port !== '') {\n        baseServer += \":\" + port.toString();\n    }\n    this.address = baseServer;\n    this.token = token;\n    this.defaultHeaders = headers;\n\n    this.get = async function (path, query, requestHeaders={}) {\n        try {\n            const format = getAccceptFormat(query);\n            let r = request\n                .get(this.address + path)\n                .set(this.token)\n                .set(this.defaultHeaders)\n                .set(requestHeaders)\n                .set('Accept', format)\n                .query(removeEmpty(query));\n            \n            if (format === 'application/msgpack') {\n                r = r.responseType('arraybuffer');\n            }\n            \n            const res = await r;\n            if (Buffer.isBuffer(res.body)) {\n                // In node res.body will be a Buffer, but in the browser it will be an ArrayBuffer\n                // (thanks superagent...), so convert it to an ArrayBuffer for consistency.\n                const underlyingArrayBuffer = res.body.buffer;\n                const start = res.body.byteOffset;\n                const end = start + res.body.byteLength;\n                res.body = underlyingArrayBuffer.slice(start, end);\n            }\n            return res;\n        } catch (e) {\n            throw e;\n        }\n    };\n\n    this.post = async function (path, data, requestHeaders={}) {\n        try {\n            return await request\n                .post(this.address + path)\n                .set(this.token)\n                .set(this.defaultHeaders)\n                .set(requestHeaders)\n                .send(data);\n        } catch (e) {\n            throw e;\n        }\n    };\n\n    this.delete = async function (path, data, requestHeaders={}) {\n        try {\n            return await request\n                .delete(this.address + path)\n                .set(this.token)\n                .set(this.defaultHeaders)\n                .set(requestHeaders)\n                .send(data);\n        } catch (e) {\n            throw e;\n        }\n    };\n}\n\nmodule.exports = { HTTPClient };"]},"metadata":{},"sourceType":"script"}