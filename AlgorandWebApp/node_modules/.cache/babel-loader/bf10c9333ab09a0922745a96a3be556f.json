{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require(\"../encoding/address\");\n\nfunction putUvarint(buf, x) {\n  let i = 0;\n\n  while (x > 0x80) {\n    buf.push(x & 0xFF | 0x80);\n    x >>= 7;\n    i += 1;\n  }\n\n  buf.push(x & 0xFF);\n  return i + 1;\n}\n\nconst valTypes = {\n  INT: 1,\n  ADDRESS: 2,\n  BASE64: 3\n};\n\nfunction inject(orig, offsets, values, valueTypes) {\n  if (offsets.length !== values.length || offsets.length !== valueTypes.length) {\n    throw new Error(\"Lengths do not match\");\n  }\n\n  let res = orig;\n\n  function replace(arr, newVal, offset, placeholderLength) {\n    let beforeReplacement = arr.slice(0, offset);\n    let afterReplacement = arr.slice(offset + placeholderLength, arr.length);\n    let chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];\n    return Buffer.concat(chunks);\n  }\n\n  for (let i = 0; i < offsets.length; i++) {\n    let decodedLength = 0;\n    let val = values[i];\n    let valType = valueTypes[i];\n\n    switch (valType) {\n      case valTypes.INT:\n        let intBuf = [];\n        decodedLength = putUvarint(intBuf, val);\n        res = replace(res, intBuf, offsets[i], 1);\n        break;\n\n      case valTypes.ADDRESS:\n        val = address.decodeAddress(val);\n        res = replace(res, val.publicKey, offsets[i], 32);\n        break;\n\n      case valTypes.BASE64:\n        let lenBuf = [];\n        val = Buffer.from(val, 'base64');\n        putUvarint(lenBuf, val.length);\n        val = Buffer.concat([Buffer.from(lenBuf), val]);\n        res = replace(res, val, offsets[i], 33);\n        break;\n\n      default:\n        throw \"unrecognized value type\";\n    }\n\n    if (decodedLength !== 0) {\n      for (let o = 0; o < offsets.length; o++) {\n        offsets[o] += decodedLength - 1;\n      }\n    }\n  }\n\n  return res;\n}\n\nmodule.exports = {\n  inject,\n  valTypes\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/templates.js"],"names":["Buffer","require","address","putUvarint","buf","x","i","push","valTypes","INT","ADDRESS","BASE64","inject","orig","offsets","values","valueTypes","length","Error","res","replace","arr","newVal","offset","placeholderLength","beforeReplacement","slice","afterReplacement","chunks","from","concat","decodedLength","val","valType","intBuf","decodeAddress","publicKey","lenBuf","o","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require(\"../encoding/address\");\n\nfunction putUvarint(buf, x){\n    let i = 0;\n    while (x > 0x80) {\n        buf.push((x&0xFF) | 0x80);\n        x >>= 7;\n        i += 1;\n    }\n    buf.push(x&0xFF);\n    return i + 1\n}\n\nconst valTypes = {\n    INT : 1,\n    ADDRESS : 2,\n    BASE64 : 3\n};\n\nfunction inject(orig, offsets, values, valueTypes) {\n    if (offsets.length !== values.length || offsets.length !== valueTypes.length) {\n        throw new Error(\"Lengths do not match\");\n    }\n\n    let res = orig;\n\n    function replace(arr, newVal, offset, placeholderLength) {\n        let beforeReplacement = arr.slice(0, offset);\n        let afterReplacement = arr.slice(offset + placeholderLength, arr.length);\n        let chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];\n        return Buffer.concat(chunks);\n    }\n\n    for (let i = 0; i < offsets.length; i++ ) {\n        let decodedLength = 0;\n        let val = values[i];\n        let valType = valueTypes[i];\n\n        switch (valType) {\n            case valTypes.INT:\n                let intBuf = [];\n                decodedLength = putUvarint(intBuf, val);\n                res = replace(res, intBuf, offsets[i], 1);\n                break;\n            case valTypes.ADDRESS:\n                val = address.decodeAddress(val);\n                res = replace(res, val.publicKey, offsets[i], 32);\n                break;\n            case valTypes.BASE64:\n                let lenBuf = [];\n                val = Buffer.from(val, 'base64');\n                putUvarint(lenBuf, val.length);\n                val = Buffer.concat([Buffer.from(lenBuf), val]);\n                res = replace(res, val, offsets[i], 33);\n                break;\n            default:\n                throw \"unrecognized value type\"\n        }\n\n        if (decodedLength !== 0) {\n            for (let o = 0; o < offsets.length; o++) {\n                offsets[o] += decodedLength - 1;\n            }\n        }\n    }\n\n    return res\n}\n\nmodule.exports = {inject, valTypes};"]},"metadata":{},"sourceType":"script"}