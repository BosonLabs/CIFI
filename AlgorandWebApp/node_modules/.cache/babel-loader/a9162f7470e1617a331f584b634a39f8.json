{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nclass SendRawTransaction {\n  constructor(c, stx_or_stxs) {\n    let forPosting = stx_or_stxs;\n\n    function isByteArray(array) {\n      return !!(array && array.byteLength !== undefined);\n    }\n\n    if (Array.isArray(stx_or_stxs)) {\n      if (!stx_or_stxs.every(isByteArray)) {\n        throw new TypeError(\"Array elements must be byte arrays\");\n      }\n\n      forPosting = Array.prototype.concat(...stx_or_stxs.map(arr => Array.from(arr)));\n    } else {\n      if (!isByteArray(forPosting)) {\n        throw new TypeError(\"Argument must be byte array\");\n      }\n    }\n\n    this.txnBytesToPost = forPosting;\n    this.c = c;\n  }\n  /**\n   * Sets the default header (if not previously set) for sending a raw\n   * transaction.\n   * @param headers\n   * @returns {*}\n   */\n\n\n  setSendTransactionHeaders(headers) {\n    let hdrs = headers;\n\n    if (Object.keys(hdrs).every(key => key.toLowerCase() !== 'content-type')) {\n      hdrs = { ...headers\n      };\n      hdrs['Content-Type'] = 'application/x-binary';\n    }\n\n    return hdrs;\n  }\n  /**\n   * broadcasts the passed signed txns to the network\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  async do(headers = {}) {\n    let txHeaders = this.setSendTransactionHeaders(headers);\n    let res = await this.c.post(\"/v2/transactions\", Buffer.from(this.txnBytesToPost), txHeaders);\n    return res.body;\n  }\n\n}\n\nmodule.exports = {\n  SendRawTransaction\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/client/v2/algod/sendRawTransaction.js"],"names":["Buffer","require","SendRawTransaction","constructor","c","stx_or_stxs","forPosting","isByteArray","array","byteLength","undefined","Array","isArray","every","TypeError","prototype","concat","map","arr","from","txnBytesToPost","setSendTransactionHeaders","headers","hdrs","Object","keys","key","toLowerCase","do","txHeaders","res","post","body","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AAEA,MAAMC,kBAAN,CAAyB;AACxBC,EAAAA,WAAW,CAACC,CAAD,EAAIC,WAAJ,EAAiB;AAC3B,QAAIC,UAAU,GAAGD,WAAjB;;AACA,aAASE,WAAT,CAAqBC,KAArB,EAA4B;AAC3B,aAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAACC,UAAN,KAAqBC,SAAhC,CAAR;AACA;;AACD,QAAIC,KAAK,CAACC,OAAN,CAAcP,WAAd,CAAJ,EAAgC;AAC/B,UAAI,CAACA,WAAW,CAACQ,KAAZ,CAAkBN,WAAlB,CAAL,EAAqC;AACpC,cAAM,IAAIO,SAAJ,CAAc,oCAAd,CAAN;AACA;;AACDR,MAAAA,UAAU,GAAGK,KAAK,CAACI,SAAN,CAAgBC,MAAhB,CAAuB,GAAGX,WAAW,CAACY,GAAZ,CAAgBC,GAAG,IAAIP,KAAK,CAACQ,IAAN,CAAWD,GAAX,CAAvB,CAA1B,CAAb;AACA,KALD,MAKO;AACN,UAAI,CAACX,WAAW,CAACD,UAAD,CAAhB,EAA8B;AAC7B,cAAM,IAAIQ,SAAJ,CAAc,6BAAd,CAAN;AACA;AACD;;AACD,SAAKM,cAAL,GAAsBd,UAAtB;AACA,SAAKF,CAAL,GAASA,CAAT;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACEiB,EAAAA,yBAAyB,CAACC,OAAD,EAAU;AACnC,QAAIC,IAAI,GAAGD,OAAX;;AACA,QAAIE,MAAM,CAACC,IAAP,CAAYF,IAAZ,EAAkBV,KAAlB,CAAwBa,GAAG,IAAGA,GAAG,CAACC,WAAJ,OAAsB,cAApD,CAAJ,EAAyE;AACxEJ,MAAAA,IAAI,GAAG,EAAC,GAAGD;AAAJ,OAAP;AACAC,MAAAA,IAAI,CAAC,cAAD,CAAJ,GAAuB,sBAAvB;AACA;;AACD,WAAOA,IAAP;AACA;AAED;AACD;AACA;AACA;AACA;;;AACC,QAAMK,EAAN,CAASN,OAAO,GAAC,EAAjB,EAAqB;AACpB,QAAIO,SAAS,GAAG,KAAKR,yBAAL,CAA+BC,OAA/B,CAAhB;AACA,QAAIQ,GAAG,GAAG,MAAM,KAAK1B,CAAL,CAAO2B,IAAP,CAAY,kBAAZ,EAAgC/B,MAAM,CAACmB,IAAP,CAAY,KAAKC,cAAjB,CAAhC,EAAkES,SAAlE,CAAhB;AACA,WAAOC,GAAG,CAACE,IAAX;AACA;;AA5CuB;;AA+CzBC,MAAM,CAACC,OAAP,GAAiB;AAAEhC,EAAAA;AAAF,CAAjB","sourcesContent":["const { Buffer } = require('buffer');\n\nclass SendRawTransaction {\n\tconstructor(c, stx_or_stxs) {\n\t\tlet forPosting = stx_or_stxs;\n\t\tfunction isByteArray(array) {\n\t\t\treturn !!(array && array.byteLength !== undefined);\n\t\t}\n\t\tif (Array.isArray(stx_or_stxs)) {\n\t\t\tif (!stx_or_stxs.every(isByteArray)) {\n\t\t\t\tthrow new TypeError(\"Array elements must be byte arrays\");\n\t\t\t}\n\t\t\tforPosting = Array.prototype.concat(...stx_or_stxs.map(arr => Array.from(arr)));\n\t\t} else {\n\t\t\tif (!isByteArray(forPosting)) {\n\t\t\t\tthrow new TypeError(\"Argument must be byte array\");\n\t\t\t}\n\t\t}\n\t\tthis.txnBytesToPost = forPosting;\n\t\tthis.c = c;\n\t}\n\n\t/**\n\t * Sets the default header (if not previously set) for sending a raw\n\t * transaction.\n\t * @param headers\n\t * @returns {*}\n\t */\n\t setSendTransactionHeaders(headers) {\n\t\tlet hdrs = headers;\n\t\tif (Object.keys(hdrs).every(key=> key.toLowerCase() !== 'content-type')) {\n\t\t\thdrs = {...headers};\n\t\t\thdrs['Content-Type'] = 'application/x-binary';\n\t\t}\n\t\treturn hdrs;\n\t}\n\n\t/**\n\t * broadcasts the passed signed txns to the network\n\t * @param headers, optional\n\t * @returns {Promise<*>}\n\t */\n\tasync do(headers={}) {\n\t\tlet txHeaders = this.setSendTransactionHeaders(headers);\n\t\tlet res = await this.c.post(\"/v2/transactions\", Buffer.from(this.txnBytesToPost), txHeaders);\n\t\treturn res.body;\n\t}\n}\n\nmodule.exports = { SendRawTransaction };\n"]},"metadata":{},"sourceType":"script"}