{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst makeTxn = require('../makeTxn');\n\nconst group = require('../group');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require('../nacl/naclWrappers');\n\nconst templates = require('./templates');\n\nconst utils = require('../utils/utils');\n\nclass LimitOrder {\n  /**\n   * MakeLimitOrder allows a user to exchange some number of assets for some number of algos.\n   * Fund the contract with some number of Algos to limit the maximum number of\n   * Algos you're willing to trade for some other asset.\n   *\n   * Works on two cases:\n   * * trading Algos for some other asset\n   * * closing out Algos back to the originator after a timeout\n   *\n   * trade case, a 2 transaction group:\n   * gtxn[0] (this txn) Algos from Me to Other\n   * gtxn[1] asset from Other to Me\n   *\n   * We want to get _at least_ some amount of the other asset per our Algos\n   * gtxn[1].AssetAmount / gtxn[0].Amount >= N / D\n   * ===\n   * gtxn[1].AssetAmount * D >= gtxn[0].Amount * N\n   *\n   * close-out case:\n   * txn alone, close out value after timeout\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {int} assetid: the ID of the transferred asset\n   * @param {int} ratn: exchange rate (N asset per D Algos, or better)\n   * @param {int} ratd: exchange rate (N asset per D Algos, or better)\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minTrade: the minimum amount (of Algos) to be traded away\n   * @param {int} maxFee: maximum fee used by the limit order transaction\n   * @returns {LimitOrder}\n   */\n  constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {\n    // don't need to validate owner - it will be validated by template.insert\n    if (!Number.isSafeInteger(assetid) || assetid < 0) throw Error(\"assetid must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(ratn) || ratn < 0) throw Error(\"ratn must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(ratd) || ratd < 0) throw Error(\"ratd must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(minTrade) || minTrade < 0) throw Error(\"minTrade must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n    const referenceProgramB64 = \"ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=\";\n    let referenceProgramBytes = Buffer.from(referenceProgramB64, \"base64\");\n    let referenceOffsets = [\n    /*maxFee*/\n    5\n    /*minTrade*/\n    , 7\n    /*assetID*/\n    , 9\n    /*ratd*/\n    , 10\n    /*ratn*/\n    , 11\n    /*expiryRound*/\n    , 12\n    /*owner*/\n    , 16];\n    let injectionVector = [maxFee, minTrade, assetid, ratd, ratn, expiryRound, owner];\n    let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS];\n    let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n    this.owner = owner;\n    this.assetid = assetid;\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: byteform of the contract from the payer\n * @param {int} assetAmount: the amount of assets to be sent\n * @param {int} microAlgoAmount: number of microAlgos to transfer\n * @param {Uint8Array} secretKey: secret key for signing transaction\n * @param {int} fee: the fee per byte to pay in microAlgos\n * @param {int} firstRound: the first round on which these txns will be valid\n * @param {int} lastRound: the last round on which these txns will be valid\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n * the first payment sends money (Algos) from contract to the recipient (we'll call him Buyer), closing the rest of the account to Owner\n * the second payment sends money (the asset) from Buyer to the Owner\n * these transactions will be rejected if they do not meet the restrictions set by the contract\n * @throws error if arguments fail contract validation\n */\n\n\nfunction getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {\n  let buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);\n  let buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);\n  let programOutputs = logic.readProgram(contract, undefined);\n  let ints = programOutputs[0];\n  let byteArrays = programOutputs[1];\n  let noCloseRemainder = undefined;\n  let noAssetRevocationTarget = undefined;\n  let contractAssetID = ints[6];\n  let contractOwner = address.encodeAddress(byteArrays[0]);\n  let lsig = logicSig.makeLogicSig(contract, undefined);\n  let contractAddress = lsig.address();\n  let algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, undefined, genesisHash, undefined);\n  let assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, undefined, genesisHash, undefined, contractAssetID);\n  let txns = [algosForAssets, assetsForAlgos];\n  let txGroup = group.assignGroupID(txns);\n  let ratd = ints[7];\n  let ratn = ints[8];\n\n  if (assetAmount * ratd < microAlgoAmount * ratn) {\n    throw new Error(\"bad payment ratio, \" + assetAmount.toString() + \"*\" + ratd.toString() + \" !>= \" + microAlgoAmount.toString() + \"*\" + ratn.toString());\n  }\n\n  let minTrade = ints[4];\n\n  if (microAlgoAmount < minTrade) {\n    throw new Error(\"payment amount \" + microAlgoAmount.toString() + \" less than minimum trade \" + minTrade.toString());\n  }\n\n  let maxFee = ints[2];\n\n  if (txGroup[0].fee > maxFee) {\n    throw new Error(\"final fee of payment transaction \" + txGroup[0].fee.toString() + \" greater than transaction max fee \" + maxFee.toString());\n  }\n\n  if (txGroup[1].fee > maxFee) {\n    throw new Error(\"final fee of asset transaction \" + txGroup[1].fee.toString() + \" greater than transaction max fee \" + maxFee.toString());\n  }\n\n  let algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);\n  let assetsForAlgosSigned = txGroup[1].signTxn(secretKey);\n  return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);\n}\n\nmodule.exports = {\n  LimitOrder,\n  getSwapAssetsTransaction\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/limitorder.js"],"names":["Buffer","require","address","makeTxn","group","logic","logicSig","nacl","templates","utils","LimitOrder","constructor","owner","assetid","ratn","ratd","expiryRound","minTrade","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","getProgram","getAddress","getSwapAssetsTransaction","contract","assetAmount","microAlgoAmount","secretKey","fee","firstRound","lastRound","genesisHash","buyerKeyPair","keyPairFromSecretKey","buyerAddr","encodeAddress","publicKey","programOutputs","readProgram","ints","byteArrays","noCloseRemainder","noAssetRevocationTarget","contractAssetID","contractOwner","makeLogicSig","contractAddress","algosForAssets","makePaymentTxn","assetsForAlgos","makeAssetTransferTxn","txns","txGroup","assignGroupID","toString","algosForAssetsSigned","signLogicSigTransactionObject","assetsForAlgosSigned","signTxn","concatArrays","blob","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\n\nclass LimitOrder {\n    /**\n     * MakeLimitOrder allows a user to exchange some number of assets for some number of algos.\n     * Fund the contract with some number of Algos to limit the maximum number of\n     * Algos you're willing to trade for some other asset.\n     *\n     * Works on two cases:\n     * * trading Algos for some other asset\n     * * closing out Algos back to the originator after a timeout\n     *\n     * trade case, a 2 transaction group:\n     * gtxn[0] (this txn) Algos from Me to Other\n     * gtxn[1] asset from Other to Me\n     *\n     * We want to get _at least_ some amount of the other asset per our Algos\n     * gtxn[1].AssetAmount / gtxn[0].Amount >= N / D\n     * ===\n     * gtxn[1].AssetAmount * D >= gtxn[0].Amount * N\n     *\n     * close-out case:\n     * txn alone, close out value after timeout\n     * Constructor Parameters:\n     * @param {string} owner: the address to refund funds to on timeout\n     * @param {int} assetid: the ID of the transferred asset\n     * @param {int} ratn: exchange rate (N asset per D Algos, or better)\n     * @param {int} ratd: exchange rate (N asset per D Algos, or better)\n     * @param {int} expiryRound: the round at which the account expires\n     * @param {int} minTrade: the minimum amount (of Algos) to be traded away\n     * @param {int} maxFee: maximum fee used by the limit order transaction\n     * @returns {LimitOrder}\n     */\n    constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {\n        // don't need to validate owner - it will be validated by template.insert\n        if (!Number.isSafeInteger(assetid) || assetid < 0) throw Error(\"assetid must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(ratn) || ratn < 0) throw Error(\"ratn must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(ratd) || ratd < 0) throw Error(\"ratd must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(minTrade) || minTrade < 0) throw Error(\"minTrade must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n\n        const referenceProgramB64 = \"ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=\";\n        let referenceProgramBytes = Buffer.from(referenceProgramB64, \"base64\");\n        let referenceOffsets = [ /*maxFee*/ 5 /*minTrade*/, 7 /*assetID*/, 9 /*ratd*/, 10 /*ratn*/, 11 /*expiryRound*/, 12 /*owner*/, 16];\n        let injectionVector =  [maxFee, minTrade, assetid, ratd, ratn, expiryRound, owner];\n        let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS];\n        let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n        this.programBytes = injectedBytes;\n        let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n        this.address = lsig.address();\n        this.owner = owner;\n        this.assetid = assetid;\n    }\n\n    /**\n     * returns the program bytes\n     * @returns {Uint8Array}\n     */\n    getProgram() {\n        return this.programBytes;\n    }\n\n    /**\n     * returns the string address of the contract\n     * @returns {string}\n     */\n    getAddress() {\n        return this.address;\n    }\n\n}\n\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: byteform of the contract from the payer\n * @param {int} assetAmount: the amount of assets to be sent\n * @param {int} microAlgoAmount: number of microAlgos to transfer\n * @param {Uint8Array} secretKey: secret key for signing transaction\n * @param {int} fee: the fee per byte to pay in microAlgos\n * @param {int} firstRound: the first round on which these txns will be valid\n * @param {int} lastRound: the last round on which these txns will be valid\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n * the first payment sends money (Algos) from contract to the recipient (we'll call him Buyer), closing the rest of the account to Owner\n * the second payment sends money (the asset) from Buyer to the Owner\n * these transactions will be rejected if they do not meet the restrictions set by the contract\n * @throws error if arguments fail contract validation\n */\nfunction getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {\n    let buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);\n    let buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);\n    let programOutputs = logic.readProgram(contract, undefined);\n    let ints = programOutputs[0];\n    let byteArrays = programOutputs[1];\n\n    let noCloseRemainder = undefined;\n    let noAssetRevocationTarget = undefined;\n    let contractAssetID = ints[6];\n    let contractOwner = address.encodeAddress(byteArrays[0]);\n    let lsig = logicSig.makeLogicSig(contract, undefined);\n    let contractAddress = lsig.address();\n    let algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, undefined, genesisHash, undefined);\n    let assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, undefined, genesisHash, undefined, contractAssetID);\n    let txns = [algosForAssets, assetsForAlgos];\n    let txGroup = group.assignGroupID(txns);\n\n    let ratd = ints[7];\n    let ratn = ints[8];\n    if ((assetAmount * ratd) < (microAlgoAmount * ratn)) {\n        throw new Error(\"bad payment ratio, \" + assetAmount.toString() + \"*\" + ratd.toString() + \" !>= \" + microAlgoAmount.toString() + \"*\" + ratn.toString())\n    }\n    let minTrade = ints[4];\n    if (microAlgoAmount < minTrade) {\n        throw new Error(\"payment amount \" + microAlgoAmount.toString() + \" less than minimum trade \" + minTrade.toString())\n    }\n    let maxFee = ints[2];\n    if (txGroup[0].fee > maxFee) {\n        throw new Error(\"final fee of payment transaction \" + txGroup[0].fee.toString() + \" greater than transaction max fee \" + maxFee.toString())\n    }\n    if (txGroup[1].fee > maxFee) {\n        throw new Error(\"final fee of asset transaction \" + txGroup[1].fee.toString() + \" greater than transaction max fee \" + maxFee.toString())\n    }\n\n    let algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);\n    let assetsForAlgosSigned = txGroup[1].signTxn(secretKey);\n    return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);\n}\n\nmodule.exports = {\n    LimitOrder,\n    getSwapAssetsTransaction\n};"]},"metadata":{},"sourceType":"script"}