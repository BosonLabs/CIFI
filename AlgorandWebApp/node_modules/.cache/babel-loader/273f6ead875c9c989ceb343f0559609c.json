{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst templates = require('./templates');\n\nconst transaction = require('../transaction');\n\nconst sha256 = require('js-sha256');\n\nconst keccak256 = require('js-sha3').keccak256;\n\nclass HTLC {\n  /**\n   * HTLC allows a user to receive the Algo prior to a deadline (in terms of a round) by proving a knowledge\n   * of a special value or to forfeit the ability to claim, returning it to the payer.\n   * This contract is usually used to perform cross-chained atomic swaps\n   *\n   * More formally -\n   * Algos can be transferred under only two circumstances:\n   * 1. To receiver if hash_function(arg_0) = hash_value\n   * 2. To owner if txn.FirstValid > expiry_round\n   * ...\n   *\n   *Parameters\n   *----------\n   * @param {string} owner: an address that can receive the asset after the expiry round\n   * @param {string} receiver: address to receive Algos\n   * @param {string} hashFunction: the hash function to be used (must be either sha256 or keccak256)\n   * @param {string} hashImage: the hash image in base64\n   * @param {int} expiryRound: the round on which the assets can be transferred back to owner\n   * @param {int} maxFee: the maximum fee that can be paid to the network by the account\n   * @returns {HTLC}\n   */\n  constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {\n    // don't need to validate owner, receiver - they'll be validated by template.insert\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n    let referenceProgramB64 = \"\";\n\n    if (hashFunction === \"sha256\") {\n      referenceProgramB64 = \"ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==\";\n    } else if (hashFunction === \"keccak256\") {\n      referenceProgramB64 = \"ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==\";\n    } else {\n      throw Error(\"hash function unrecognized\");\n    } // validate hashImage length\n\n\n    let hashImageBytes = Buffer.from(hashImage, 'base64');\n    if (hashImageBytes.length !== 32) throw Error(\"hash image must be 32 bytes\");\n    let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    let referenceOffsets = [\n    /*fee*/\n    3\n    /*expiryRound*/\n    , 6\n    /*receiver*/\n    , 10\n    /*hashImage*/\n    , 42\n    /*owner*/\n    , 76];\n    let injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];\n    let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.BASE64, templates.valTypes.ADDRESS];\n    let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n *  signTransactionWithHTLCUnlock accepts a transaction, such as a payment, and builds the HTLC-unlocking signature around that transaction\n* @param {Uint8Array} contract : byte representation of the HTLC\n* @param {Object} txn dictionary containing constructor arguments for a transaction\n* @param {string} preImageAsBase64 : preimage of the hash as base64 string\n*\n* @returns {Object} Object containing txID and blob representing signed transaction.\n* @throws error on validation failure\n */\n\n\nfunction signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {\n  let preImageBytes = Buffer.from(preImageAsBase64, 'base64'); // hash validation\n\n  let readResult = logic.readProgram(contract, undefined);\n  let ints = readResult[0];\n  let byteArrays = readResult[1];\n  let expectedHashedOutput = byteArrays[1];\n  let hashFunction = contract[contract.length - 15];\n\n  if (hashFunction === 1) {\n    let hash = sha256.create();\n    hash.update(preImageBytes);\n    let actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error(\"sha256 hash of preimage did not match stored contract hash\");\n    }\n  } else if (hashFunction === 2) {\n    let hash = keccak256.create();\n    hash.update(preImageBytes);\n    let actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n\n    if (!actualHashedOutput.equals(expectedHashedOutput)) {\n      throw new Error(\"keccak256 hash of preimage did not match stored contract hash\");\n    }\n  } else {\n    throw new Error(\"hash function in contract unrecognized\");\n  }\n\n  let args = [preImageBytes]; // array of one element, the Uint8Array preimage\n\n  let lsig = new logicSig.LogicSig(contract, args); // clear out receiver just in case\n\n  delete txn.to;\n  let maxFee = ints[0]; // check fee\n\n  let tempTxn = new transaction.Transaction(txn);\n\n  if (tempTxn.fee > maxFee) {\n    throw new Error(\"final fee of payment transaction\" + tempTxn.fee.toString() + \"greater than transaction max fee\" + maxFee.toString());\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n  HTLC,\n  signTransactionWithHTLCUnlock\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/htlc.js"],"names":["Buffer","require","logic","logicSig","templates","transaction","sha256","keccak256","HTLC","constructor","owner","receiver","hashFunction","hashImage","expiryRound","maxFee","Number","isSafeInteger","Error","referenceProgramB64","hashImageBytes","from","length","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","BASE64","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","address","getProgram","getAddress","signTransactionWithHTLCUnlock","contract","txn","preImageAsBase64","preImageBytes","readResult","readProgram","ints","byteArrays","expectedHashedOutput","hash","create","update","actualHashedOutput","hex","equals","args","to","tempTxn","Transaction","fee","toString","signLogicSigTransaction","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst templates = require('./templates');\nconst transaction = require('../transaction');\nconst sha256 = require('js-sha256');\nconst keccak256 = require('js-sha3').keccak256;\n\nclass HTLC {\n    /**\n     * HTLC allows a user to receive the Algo prior to a deadline (in terms of a round) by proving a knowledge\n     * of a special value or to forfeit the ability to claim, returning it to the payer.\n     * This contract is usually used to perform cross-chained atomic swaps\n     *\n     * More formally -\n     * Algos can be transferred under only two circumstances:\n     * 1. To receiver if hash_function(arg_0) = hash_value\n     * 2. To owner if txn.FirstValid > expiry_round\n     * ...\n     *\n     *Parameters\n     *----------\n     * @param {string} owner: an address that can receive the asset after the expiry round\n     * @param {string} receiver: address to receive Algos\n     * @param {string} hashFunction: the hash function to be used (must be either sha256 or keccak256)\n     * @param {string} hashImage: the hash image in base64\n     * @param {int} expiryRound: the round on which the assets can be transferred back to owner\n     * @param {int} maxFee: the maximum fee that can be paid to the network by the account\n     * @returns {HTLC}\n     */\n    constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {\n        // don't need to validate owner, receiver - they'll be validated by template.insert\n        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n\n        let referenceProgramB64 = \"\";\n        if (hashFunction === \"sha256\") {\n            referenceProgramB64 = \"ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==\";\n        } else if (hashFunction === \"keccak256\") {\n            referenceProgramB64 = \"ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==\";\n        } else {\n            throw Error(\"hash function unrecognized\");\n        }\n        // validate hashImage length\n        let hashImageBytes = Buffer.from(hashImage, 'base64');\n        if (hashImageBytes.length !== 32) throw Error(\"hash image must be 32 bytes\");\n\n        let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n        let referenceOffsets = [ /*fee*/ 3 /*expiryRound*/, 6 /*receiver*/, 10 /*hashImage*/, 42 /*owner*/, 76];\n        let injectionVector =  [maxFee, expiryRound, receiver, hashImage, owner];\n        let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.BASE64, templates.valTypes.ADDRESS];\n        let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n        this.programBytes = injectedBytes;\n        let lsig = new logicSig.LogicSig(injectedBytes, undefined);\n        this.address = lsig.address();\n    }\n\n    /**\n     * returns the program bytes\n     * @returns {Uint8Array}\n     */\n    getProgram() {\n        return this.programBytes;\n    }\n\n    /**\n     * returns the string address of the contract\n     * @returns {string}\n     */\n    getAddress() {\n        return this.address;\n    }\n}\n\n/**\n *  signTransactionWithHTLCUnlock accepts a transaction, such as a payment, and builds the HTLC-unlocking signature around that transaction\n* @param {Uint8Array} contract : byte representation of the HTLC\n* @param {Object} txn dictionary containing constructor arguments for a transaction\n* @param {string} preImageAsBase64 : preimage of the hash as base64 string\n*\n* @returns {Object} Object containing txID and blob representing signed transaction.\n* @throws error on validation failure\n */\nfunction signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {\n    let preImageBytes = Buffer.from(preImageAsBase64, 'base64');\n\n    // hash validation\n    let readResult = logic.readProgram(contract, undefined);\n    let ints = readResult[0];\n    let byteArrays = readResult[1];\n    let expectedHashedOutput = byteArrays[1];\n    let hashFunction = contract[contract.length - 15];\n    if (hashFunction === 1) {\n        let hash = sha256.create();\n        hash.update(preImageBytes);\n        let actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n        if (!actualHashedOutput.equals(expectedHashedOutput)) {\n            throw new Error(\"sha256 hash of preimage did not match stored contract hash\")\n        }\n    } else if (hashFunction === 2) {\n        let hash = keccak256.create();\n        hash.update(preImageBytes);\n        let actualHashedOutput = Buffer.from(hash.hex(), 'hex');\n        if (!actualHashedOutput.equals(expectedHashedOutput)) {\n            throw new Error(\"keccak256 hash of preimage did not match stored contract hash\")\n        }\n    } else {\n        throw new Error(\"hash function in contract unrecognized\")\n    }\n\n    let args = [preImageBytes]; // array of one element, the Uint8Array preimage\n\n    let lsig = new logicSig.LogicSig(contract, args);\n    // clear out receiver just in case\n    delete txn.to;\n\n\n    let maxFee = ints[0];\n    // check fee\n    let tempTxn = new transaction.Transaction(txn);\n    if (tempTxn.fee > maxFee) {\n        throw new Error(\"final fee of payment transaction\" + tempTxn.fee.toString() + \"greater than transaction max fee\" + maxFee.toString())\n    }\n\n    return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n    HTLC,\n    signTransactionWithHTLCUnlock\n};\n"]},"metadata":{},"sourceType":"script"}