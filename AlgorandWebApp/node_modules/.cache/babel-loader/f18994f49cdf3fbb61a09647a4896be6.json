{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst mnemonic = require('./mnemonic/mnemonic');\n\nconst encoding = require('./encoding/encoding');\n\nconst account = require('./account');\n\nconst txnBuilder = require('./transaction');\n\nconst makeTxn = require('./makeTxn');\n\nconst group = require('./group');\n\nconst multisig = require('./multisig');\n\nconst bidBuilder = require('./bid');\n\nconst algod = require('./client/algod');\n\nconst kmd = require('./client/kmd');\n\nconst convert = require('./convert');\n\nconst utils = require('./utils/utils');\n\nconst logicsig = require('./logicsig');\n\nconst LogicTemplates = require('./logicTemplates');\n\nconst algodv2 = require('./client/v2/algod/algod');\n\nconst modelsv2 = require('./client/v2/algod/models/types');\n\nconst indexer = require('./client/v2/indexer/indexer');\n\nlet Algod = algod.Algod;\nlet Kmd = kmd.Kmd;\nlet Algodv2 = algodv2.AlgodClient;\nlet Indexer = indexer.IndexerClient;\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n// Errors\n\nconst ERROR_MULTISIG_BAD_SENDER = new Error(\"The transaction sender address and multisig preimage do not match.\");\n/**\n * signTransaction takes an object with either payment or key registration fields and \n * a secret key and returns a signed blob.\n * \n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n * \n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn object with either payment or key registration fields\n * @param sk Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\n\nfunction signTransaction(txn, sk) {\n  if (!txn.from) {\n    // Get pk from sk if no sender specified\n    let key = nacl.keyPairFromSecretKey(sk);\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n\n  let algoTxn = txn;\n\n  if (!(txn instanceof txnBuilder.Transaction)) {\n    algoTxn = new txnBuilder.Transaction(txn);\n  }\n\n  return {\n    \"txID\": algoTxn.txID().toString(),\n    \"blob\": algoTxn.signTxn(sk)\n  };\n}\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid Algorand Bid\n * @param sk Algorand secret key\n * @returns Uint8Array binary signed bid\n */\n\n\nfunction signBid(bid, sk) {\n  let signedBid = new bidBuilder.Bid(bid);\n  return signedBid.signBid(sk);\n}\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes \n * with the private key, and returns the signature.\n * @param bytes Uint8array\n * @param sk Algorand secret key\n * @returns binary signature\n */\n\n\nfunction signBytes(bytes, sk) {\n  let toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  let sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes Uint8Array\n * @param signature binary signature\n * @param addr string address\n * @returns bool\n */\n\n\nfunction verifyBytes(bytes, signature, addr) {\n  toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  let pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.\n * @param txn object with either payment or key registration fields\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\n\n\nfunction signMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  let expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n\n  if (txn.hasOwnProperty('from')) {\n    if (txn.from !== expectedFromRaw && address.encodeAddress(txn.from.publicKey) !== expectedFromRaw) {\n      throw ERROR_MULTISIG_BAD_SENDER;\n    }\n  } else {\n    txn.from = expectedFromRaw;\n  } // build pks for partialSign\n\n\n  const pks = addrs.map(addr => {\n    return address.decodeAddress(addr).publicKey;\n  }); // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n\n  let txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = multisig.MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new multisig.MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n\n  return {\n    \"txID\": algoTxn.txID().toString(),\n    \"blob\": blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\n\n\nfunction appendSignMultisigTransaction(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  const pks = addrs.map(addr => {\n    return address.decodeAddress(addr).publicKey;\n  }); // obtain underlying txn, sign it, and merge it\n\n  let multisigTxObj = encoding.decode(multisigTxnBlob);\n  let msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  let partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    \"txID\": msigTxn.txID().toString(),\n    \"blob\": mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns blob representing encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  return multisig.mergeMultisigTransactions(multisigTxnBlobs);\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version mutlisig version\n * @param threshold multisig threshold\n * @param addrs list of Algorand addresses\n */\n\n\nfunction multisigAddress({\n  version,\n  threshold,\n  addrs\n}) {\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o js obj\n * @returns Uint8Array binary representation\n */\n\n\nfunction encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o Uint8Array to decode\n * @returns object\n */\n\n\nfunction decodeObj(o) {\n  return encoding.decode(o);\n}\n\nmodule.exports = {\n  isValidAddress: address.isValidAddress,\n  encodeAddress: address.encodeAddress,\n  decodeAddress: address.decodeAddress,\n  generateAccount: account.generateAccount,\n  secretKeyToMnemonic: mnemonic.secretKeyToMnemonic,\n  mnemonicToSecretKey: mnemonic.mnemonicToSecretKey,\n  signTransaction,\n  signBid,\n  signBytes,\n  verifyBytes,\n  encodeObj,\n  decodeObj,\n  Algod,\n  Kmd,\n  Algodv2,\n  Indexer,\n  modelsv2,\n  mnemonicToMasterDerivationKey: mnemonic.mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic: mnemonic.masterDerivationKeyToMnemonic,\n  appendSignMultisigTransaction,\n  mergeMultisigTransactions,\n  signMultisigTransaction,\n  multisigAddress,\n  ERROR_MULTISIG_BAD_SENDER,\n  ERROR_INVALID_MICROALGOS: convert.ERROR_INVALID_MICROALGOS,\n  microalgosToAlgos: convert.microalgosToAlgos,\n  algosToMicroalgos: convert.algosToMicroalgos,\n  computeGroupID: group.computeGroupID,\n  assignGroupID: group.assignGroupID,\n  makeLogicSig: logicsig.makeLogicSig,\n  signLogicSigTransaction: logicsig.signLogicSigTransaction,\n  signLogicSigTransactionObject: logicsig.signLogicSigTransactionObject,\n  logicSigFromByte: logicsig.logicSigFromByte,\n  tealSign: logicsig.tealSign,\n  tealSignFromProgram: logicsig.tealSignFromProgram,\n  makePaymentTxn: makeTxn.makePaymentTxn,\n  makeKeyRegistrationTxn: makeTxn.makeKeyRegistrationTxn,\n  makeAssetCreateTxn: makeTxn.makeAssetCreateTxn,\n  makeAssetConfigTxn: makeTxn.makeAssetConfigTxn,\n  makeAssetDestroyTxn: makeTxn.makeAssetDestroyTxn,\n  makeAssetFreezeTxn: makeTxn.makeAssetFreezeTxn,\n  makeAssetTransferTxn: makeTxn.makeAssetTransferTxn,\n  makePaymentTxnWithSuggestedParams: makeTxn.makePaymentTxnWithSuggestedParams,\n  makeKeyRegistrationTxnWithSuggestedParams: makeTxn.makeKeyRegistrationTxnWithSuggestedParams,\n  makeAssetCreateTxnWithSuggestedParams: makeTxn.makeAssetCreateTxnWithSuggestedParams,\n  makeAssetConfigTxnWithSuggestedParams: makeTxn.makeAssetConfigTxnWithSuggestedParams,\n  makeAssetDestroyTxnWithSuggestedParams: makeTxn.makeAssetDestroyTxnWithSuggestedParams,\n  makeAssetFreezeTxnWithSuggestedParams: makeTxn.makeAssetFreezeTxnWithSuggestedParams,\n  makeAssetTransferTxnWithSuggestedParams: makeTxn.makeAssetTransferTxnWithSuggestedParams,\n  makePaymentTxnWithSuggestedParamsFromObject: makeTxn.makePaymentTxnWithSuggestedParamsFromObject,\n  makeKeyRegistrationTxnWithSuggestedParamsFromObject: makeTxn.makeKeyRegistrationTxnWithSuggestedParamsFromObject,\n  makeAssetCreateTxnWithSuggestedParamsFromObject: makeTxn.makeAssetCreateTxnWithSuggestedParamsFromObject,\n  makeAssetConfigTxnWithSuggestedParamsFromObject: makeTxn.makeAssetConfigTxnWithSuggestedParamsFromObject,\n  makeAssetDestroyTxnWithSuggestedParamsFromObject: makeTxn.makeAssetDestroyTxnWithSuggestedParamsFromObject,\n  makeAssetFreezeTxnWithSuggestedParamsFromObject: makeTxn.makeAssetFreezeTxnWithSuggestedParamsFromObject,\n  makeAssetTransferTxnWithSuggestedParamsFromObject: makeTxn.makeAssetTransferTxnWithSuggestedParamsFromObject,\n  OnApplicationComplete: makeTxn.OnApplicationComplete,\n  makeApplicationCreateTxn: makeTxn.makeApplicationCreateTxn,\n  makeApplicationUpdateTxn: makeTxn.makeApplicationUpdateTxn,\n  makeApplicationDeleteTxn: makeTxn.makeApplicationDeleteTxn,\n  makeApplicationOptInTxn: makeTxn.makeApplicationOptInTxn,\n  makeApplicationCloseOutTxn: makeTxn.makeApplicationCloseOutTxn,\n  makeApplicationClearStateTxn: makeTxn.makeApplicationClearStateTxn,\n  makeApplicationNoOpTxn: makeTxn.makeApplicationNoOpTxn,\n  makeApplicationCreateTxnFromObject: makeTxn.makeApplicationCreateTxnFromObject,\n  makeApplicationUpdateTxnFromObject: makeTxn.makeApplicationUpdateTxnFromObject,\n  makeApplicationDeleteTxnFromObject: makeTxn.makeApplicationDeleteTxnFromObject,\n  makeApplicationOptInTxnFromObject: makeTxn.makeApplicationOptInTxnFromObject,\n  makeApplicationCloseOutTxnFromObject: makeTxn.makeApplicationCloseOutTxnFromObject,\n  makeApplicationClearStateTxnFromObject: makeTxn.makeApplicationClearStateTxnFromObject,\n  makeApplicationNoOpTxnFromObject: makeTxn.makeApplicationNoOpTxnFromObject,\n  encodeUnsignedTransaction: txnBuilder.encodeUnsignedTransaction,\n  decodeUnsignedTransaction: txnBuilder.decodeUnsignedTransaction,\n  decodeSignedTransaction: txnBuilder.decodeSignedTransaction,\n  Transaction: txnBuilder.Transaction,\n  LogicTemplates\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/main.js"],"names":["Buffer","require","nacl","address","mnemonic","encoding","account","txnBuilder","makeTxn","group","multisig","bidBuilder","algod","kmd","convert","utils","logicsig","LogicTemplates","algodv2","modelsv2","indexer","Algod","Kmd","Algodv2","AlgodClient","Indexer","IndexerClient","SIGN_BYTES_PREFIX","from","ERROR_MULTISIG_BAD_SENDER","Error","signTransaction","txn","sk","key","keyPairFromSecretKey","encodeAddress","publicKey","algoTxn","Transaction","txID","toString","signTxn","signBid","bid","signedBid","Bid","signBytes","bytes","toBeSigned","concatArrays","sig","sign","verifyBytes","signature","addr","toBeVerified","pk","decodeAddress","verify","signMultisigTransaction","version","threshold","addrs","expectedFromRaw","fromMultisigPreImgAddrs","hasOwnProperty","pks","map","txnAlreadyBuilt","blob","MultisigTransaction","prototype","partialSignTxn","call","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","decode","msigTxn","from_obj_for_encoding","partialSignedBlob","mergeMultisigTransactions","multisigTxnBlobs","multisigAddress","encodeObj","o","Uint8Array","encode","decodeObj","module","exports","isValidAddress","generateAccount","secretKeyToMnemonic","mnemonicToSecretKey","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","ERROR_INVALID_MICROALGOS","microalgosToAlgos","algosToMicroalgos","computeGroupID","assignGroupID","makeLogicSig","signLogicSigTransaction","signLogicSigTransactionObject","logicSigFromByte","tealSign","tealSignFromProgram","makePaymentTxn","makeKeyRegistrationTxn","makeAssetCreateTxn","makeAssetConfigTxn","makeAssetDestroyTxn","makeAssetFreezeTxn","makeAssetTransferTxn","makePaymentTxnWithSuggestedParams","makeKeyRegistrationTxnWithSuggestedParams","makeAssetCreateTxnWithSuggestedParams","makeAssetConfigTxnWithSuggestedParams","makeAssetDestroyTxnWithSuggestedParams","makeAssetFreezeTxnWithSuggestedParams","makeAssetTransferTxnWithSuggestedParams","makePaymentTxnWithSuggestedParamsFromObject","makeKeyRegistrationTxnWithSuggestedParamsFromObject","makeAssetCreateTxnWithSuggestedParamsFromObject","makeAssetConfigTxnWithSuggestedParamsFromObject","makeAssetDestroyTxnWithSuggestedParamsFromObject","makeAssetFreezeTxnWithSuggestedParamsFromObject","makeAssetTransferTxnWithSuggestedParamsFromObject","OnApplicationComplete","makeApplicationCreateTxn","makeApplicationUpdateTxn","makeApplicationDeleteTxn","makeApplicationOptInTxn","makeApplicationCloseOutTxn","makeApplicationClearStateTxn","makeApplicationNoOpTxn","makeApplicationCreateTxnFromObject","makeApplicationUpdateTxnFromObject","makeApplicationDeleteTxnFromObject","makeApplicationOptInTxnFromObject","makeApplicationCloseOutTxnFromObject","makeApplicationClearStateTxnFromObject","makeApplicationNoOpTxnFromObject","encodeUnsignedTransaction","decodeUnsignedTransaction","decodeSignedTransaction"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst mnemonic = require('./mnemonic/mnemonic');\nconst encoding = require('./encoding/encoding');\nconst account = require('./account');\nconst txnBuilder = require('./transaction');\nconst makeTxn = require('./makeTxn');\nconst group = require('./group');\nconst multisig = require('./multisig');\nconst bidBuilder = require('./bid');\nconst algod = require('./client/algod');\nconst kmd = require('./client/kmd');\nconst convert = require('./convert');\nconst utils = require('./utils/utils');\nconst logicsig = require('./logicsig');\nconst LogicTemplates = require('./logicTemplates');\nconst algodv2 = require('./client/v2/algod/algod')\nconst modelsv2 = require('./client/v2/algod/models/types')\nconst indexer = require('./client/v2/indexer/indexer')\n\nlet Algod = algod.Algod;\nlet Kmd = kmd.Kmd;\nlet Algodv2 = algodv2.AlgodClient\nlet Indexer = indexer.IndexerClient\n\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n\n// Errors\nconst ERROR_MULTISIG_BAD_SENDER = new Error(\"The transaction sender address and multisig preimage do not match.\");\n\n/**\n * signTransaction takes an object with either payment or key registration fields and \n * a secret key and returns a signed blob.\n * \n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n * \n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn object with either payment or key registration fields\n * @param sk Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nfunction signTransaction(txn, sk) {\n    if (!txn.from) {\n        // Get pk from sk if no sender specified\n        let key = nacl.keyPairFromSecretKey(sk);\n        txn.from = address.encodeAddress(key.publicKey);\n    }\n    let algoTxn = txn;\n    if (! (txn instanceof txnBuilder.Transaction)) {\n        algoTxn = new txnBuilder.Transaction(txn);\n    }\n\n    return {\"txID\": algoTxn.txID().toString(), \"blob\": algoTxn.signTxn(sk)};\n}\n\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid Algorand Bid\n * @param sk Algorand secret key\n * @returns Uint8Array binary signed bid\n */\nfunction signBid(bid, sk) {\n    let signedBid = new bidBuilder.Bid(bid);\n    return signedBid.signBid(sk);\n}\n\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes \n * with the private key, and returns the signature.\n * @param bytes Uint8array\n * @param sk Algorand secret key\n * @returns binary signature\n */\nfunction signBytes(bytes, sk) {\n    let toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n    let sig = nacl.sign(toBeSigned, sk);\n    return sig;\n}\n\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes Uint8Array\n * @param signature binary signature\n * @param addr string address\n * @returns bool\n */\nfunction verifyBytes(bytes, signature, addr) {\n    toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n    let pk = address.decodeAddress(addr).publicKey;\n    return nacl.verify(toBeVerified, signature, pk);\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.\n * @param txn object with either payment or key registration fields\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nfunction signMultisigTransaction(txn, {version, threshold, addrs}, sk) {\n    // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n    let expectedFromRaw = address.fromMultisigPreImgAddrs({version, threshold, addrs});\n    if (txn.hasOwnProperty('from')) {\n        if ((txn.from !== expectedFromRaw) && (address.encodeAddress(txn.from.publicKey) !== expectedFromRaw)) {\n            throw ERROR_MULTISIG_BAD_SENDER;\n        }\n    } else {\n        txn.from = expectedFromRaw;\n    }\n    // build pks for partialSign\n    const pks = addrs.map(addr => {\n        return address.decodeAddress(addr).publicKey;\n    });\n    // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n    let txnAlreadyBuilt = (txn instanceof txnBuilder.Transaction);\n    let algoTxn;\n    let blob;\n    if (txnAlreadyBuilt) {\n        algoTxn = txn;\n        blob = multisig.MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {version, threshold, pks}, sk);\n    } else {\n        algoTxn = new multisig.MultisigTransaction(txn);\n        blob = algoTxn.partialSignTxn({version, threshold, pks}, sk);\n    }\n    return {\n        \"txID\": algoTxn.txID().toString(),\n        \"blob\": blob\n    };\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nfunction appendSignMultisigTransaction(multisigTxnBlob, {version, threshold, addrs}, sk) {\n    const pks = addrs.map(addr => {\n        return address.decodeAddress(addr).publicKey;\n    });\n    // obtain underlying txn, sign it, and merge it\n    let multisigTxObj = encoding.decode(multisigTxnBlob);\n    let msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n    let partialSignedBlob = msigTxn.partialSignTxn({version, threshold, pks}, sk);\n    return {\n        \"txID\": msigTxn.txID().toString(),\n        \"blob\": mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n    };\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns blob representing encoded multisig txn\n */\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n    return multisig.mergeMultisigTransactions(multisigTxnBlobs);\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version mutlisig version\n * @param threshold multisig threshold\n * @param addrs list of Algorand addresses\n */\nfunction multisigAddress({version, threshold, addrs}) {\n    return address.fromMultisigPreImgAddrs({version, threshold, addrs});\n}\n\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o js obj\n * @returns Uint8Array binary representation\n */\nfunction encodeObj(o) {\n    return new Uint8Array(encoding.encode(o));\n}\n\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o Uint8Array to decode\n * @returns object\n */\nfunction decodeObj(o) {\n    return encoding.decode(o);\n}\n\nmodule.exports = {\n    isValidAddress: address.isValidAddress,\n    encodeAddress: address.encodeAddress,\n    decodeAddress: address.decodeAddress,\n    generateAccount: account.generateAccount,\n    secretKeyToMnemonic: mnemonic.secretKeyToMnemonic,\n    mnemonicToSecretKey: mnemonic.mnemonicToSecretKey,\n    signTransaction,\n    signBid,\n    signBytes,\n    verifyBytes,\n    encodeObj,\n    decodeObj,\n    Algod,\n    Kmd,\n    Algodv2,\n    Indexer,\n    modelsv2,\n    mnemonicToMasterDerivationKey: mnemonic.mnemonicToMasterDerivationKey,\n    masterDerivationKeyToMnemonic: mnemonic.masterDerivationKeyToMnemonic,\n    appendSignMultisigTransaction,\n    mergeMultisigTransactions,\n    signMultisigTransaction,\n    multisigAddress,\n    ERROR_MULTISIG_BAD_SENDER,\n    ERROR_INVALID_MICROALGOS: convert.ERROR_INVALID_MICROALGOS,\n    microalgosToAlgos: convert.microalgosToAlgos,\n    algosToMicroalgos: convert.algosToMicroalgos,\n    computeGroupID: group.computeGroupID,\n    assignGroupID: group.assignGroupID,\n    makeLogicSig: logicsig.makeLogicSig,\n    signLogicSigTransaction: logicsig.signLogicSigTransaction,\n    signLogicSigTransactionObject: logicsig.signLogicSigTransactionObject,\n    logicSigFromByte: logicsig.logicSigFromByte,\n    tealSign: logicsig.tealSign,\n    tealSignFromProgram: logicsig.tealSignFromProgram,\n    makePaymentTxn: makeTxn.makePaymentTxn,\n    makeKeyRegistrationTxn: makeTxn.makeKeyRegistrationTxn,\n    makeAssetCreateTxn: makeTxn.makeAssetCreateTxn,\n    makeAssetConfigTxn: makeTxn.makeAssetConfigTxn,\n    makeAssetDestroyTxn: makeTxn.makeAssetDestroyTxn,\n    makeAssetFreezeTxn: makeTxn.makeAssetFreezeTxn,\n    makeAssetTransferTxn: makeTxn.makeAssetTransferTxn,\n    makePaymentTxnWithSuggestedParams: makeTxn.makePaymentTxnWithSuggestedParams,\n    makeKeyRegistrationTxnWithSuggestedParams: makeTxn.makeKeyRegistrationTxnWithSuggestedParams,\n    makeAssetCreateTxnWithSuggestedParams: makeTxn.makeAssetCreateTxnWithSuggestedParams,\n    makeAssetConfigTxnWithSuggestedParams: makeTxn.makeAssetConfigTxnWithSuggestedParams,\n    makeAssetDestroyTxnWithSuggestedParams: makeTxn.makeAssetDestroyTxnWithSuggestedParams,\n    makeAssetFreezeTxnWithSuggestedParams: makeTxn.makeAssetFreezeTxnWithSuggestedParams,\n    makeAssetTransferTxnWithSuggestedParams: makeTxn.makeAssetTransferTxnWithSuggestedParams,\n    makePaymentTxnWithSuggestedParamsFromObject: makeTxn.makePaymentTxnWithSuggestedParamsFromObject,\n    makeKeyRegistrationTxnWithSuggestedParamsFromObject: makeTxn.makeKeyRegistrationTxnWithSuggestedParamsFromObject,\n    makeAssetCreateTxnWithSuggestedParamsFromObject: makeTxn.makeAssetCreateTxnWithSuggestedParamsFromObject,\n    makeAssetConfigTxnWithSuggestedParamsFromObject: makeTxn.makeAssetConfigTxnWithSuggestedParamsFromObject,\n    makeAssetDestroyTxnWithSuggestedParamsFromObject: makeTxn.makeAssetDestroyTxnWithSuggestedParamsFromObject,\n    makeAssetFreezeTxnWithSuggestedParamsFromObject: makeTxn.makeAssetFreezeTxnWithSuggestedParamsFromObject,\n    makeAssetTransferTxnWithSuggestedParamsFromObject: makeTxn.makeAssetTransferTxnWithSuggestedParamsFromObject,\n    OnApplicationComplete: makeTxn.OnApplicationComplete,\n    makeApplicationCreateTxn: makeTxn.makeApplicationCreateTxn,\n    makeApplicationUpdateTxn: makeTxn.makeApplicationUpdateTxn,\n    makeApplicationDeleteTxn: makeTxn.makeApplicationDeleteTxn,\n    makeApplicationOptInTxn: makeTxn.makeApplicationOptInTxn,\n    makeApplicationCloseOutTxn: makeTxn.makeApplicationCloseOutTxn,\n    makeApplicationClearStateTxn: makeTxn.makeApplicationClearStateTxn,\n    makeApplicationNoOpTxn: makeTxn.makeApplicationNoOpTxn,\n    makeApplicationCreateTxnFromObject: makeTxn.makeApplicationCreateTxnFromObject,\n    makeApplicationUpdateTxnFromObject: makeTxn.makeApplicationUpdateTxnFromObject,\n    makeApplicationDeleteTxnFromObject: makeTxn.makeApplicationDeleteTxnFromObject,\n    makeApplicationOptInTxnFromObject: makeTxn.makeApplicationOptInTxnFromObject,\n    makeApplicationCloseOutTxnFromObject: makeTxn.makeApplicationCloseOutTxnFromObject,\n    makeApplicationClearStateTxnFromObject: makeTxn.makeApplicationClearStateTxnFromObject,\n    makeApplicationNoOpTxnFromObject: makeTxn.makeApplicationNoOpTxnFromObject,\n    encodeUnsignedTransaction: txnBuilder.encodeUnsignedTransaction,\n    decodeUnsignedTransaction: txnBuilder.decodeUnsignedTransaction,\n    decodeSignedTransaction: txnBuilder.decodeSignedTransaction,\n    Transaction: txnBuilder.Transaction,\n    LogicTemplates,\n};\n"]},"metadata":{},"sourceType":"script"}