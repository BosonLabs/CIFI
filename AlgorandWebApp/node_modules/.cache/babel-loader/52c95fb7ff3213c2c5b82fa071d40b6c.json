{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require(\"../encoding/address\");\n\nconst makeTxn = require('../makeTxn');\n\nconst logic = require('../logic/logic');\n\nconst logicSig = require('../logicsig');\n\nconst nacl = require(\"../nacl/naclWrappers\");\n\nconst templates = require('./templates');\n\nclass PeriodicPayment {\n  /**\n   * MakePeriodicPayment allows some account to execute periodic withdrawal of funds.\n   * This is a contract account.\n   *\n   * This allows receiver to withdraw amount every\n   * period rounds for withdrawWindow after every multiple\n   * of period.\n   *\n   * After expiryRound, all remaining funds in the escrow\n   * are available to receiver.\n   *\n   * Constructor Parameters:\n   * @param {string} receiver: address which is authorized to receive withdrawals\n   * @param {int} amount: the amount to send each period\n   * @param {int} withdrawalWindow: the duration of a withdrawal period\n   * @param {int} period: the time between a pair of withdrawal periods\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} maxFee: maximum fee used by the withdrawal transaction\n   * @param {string} lease: b64 representation of lease to use, or leave undefined to generate one\n   * @returns {PeriodicPayment}\n   */\n  constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {\n    // don't need to validate receiver or lease, it's validated by template insert\n    this.receiver = receiver;\n    if (!Number.isSafeInteger(amount) || amount < 0) throw Error(\"amount must be a positive number and smaller than 2^53-1\");\n    this.amount = amount;\n    if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0) throw Error(\"withdrawalWindow must be a positive number and smaller than 2^53-1\");\n    this.withdrawalWindow = withdrawalWindow;\n    if (!Number.isSafeInteger(period) || period < 0) throw Error(\"period must be a positive number and smaller than 2^53-1\");\n    this.period = period;\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n    this.expiryRound = expiryRound;\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n    this.maxFee = maxFee;\n\n    if (lease === undefined) {\n      let leaseBytes = nacl.randomBytes(32);\n      this.lease = Buffer.from(leaseBytes).toString('base64');\n    } else {\n      this.lease = lease;\n    }\n\n    this.programBytes = this.getProgram();\n    let lsig = new logicSig.LogicSig(this.programBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    const referenceProgramB64 = \"ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ\";\n    let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    let referenceOffsets = [\n    /*fee*/\n    4\n    /*period*/\n    , 5\n    /*withdrawWindow*/\n    , 7\n    /*amount*/\n    , 8\n    /*expiryRound*/\n    , 9\n    /*lease*/\n    , 12\n    /*receiver*/\n    , 46];\n    let injectionVector = [this.maxFee, this.period, this.withdrawalWindow, this.amount, this.expiryRound, this.lease, this.receiver];\n    let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.BASE64, templates.valTypes.ADDRESS];\n    return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * getPeriodicPaymentWithdrawalTransaction returns a signed transaction extracting funds form the contract\n * @param {Uint8Array} contract: the bytearray defining the contract, received from the payer\n * @param {int} fee: the fee per byte for the transaction\n * @param {int} firstValid: the first round on which the txn will be valid\n * @param {string} genesisHash: the hash representing the network for the txn\n * @returns {Object} Object containing txID and blob representing signed transaction\n * @throws error on failure\n */\n\n\nfunction getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {\n  let readResult = logic.readProgram(contract, undefined);\n  let ints = readResult[0];\n  let byteArrays = readResult[1];\n  let period = ints[2];\n  let duration = ints[4];\n  let amount = ints[5];\n\n  if (firstValid % period !== 0) {\n    throw new Error(\"firstValid round \" + firstValid.toString() + \" was not a multiple of contract period \" + period.toString());\n  } // extract receiver and convert as needed\n\n\n  let receiverBytes = byteArrays[1];\n  let receiver = address.encodeAddress(receiverBytes); // extract lease and convert\n\n  let leaseBuffer = byteArrays[0];\n  let lease = new Uint8Array(leaseBuffer);\n  let lastValid = firstValid + duration;\n  let to = receiver;\n  let noCloseRemainder = undefined;\n  let noNote = undefined;\n  let lsig = logicSig.makeLogicSig(contract, undefined);\n  let from = lsig.address();\n  let txn = {\n    \"from\": from,\n    \"to\": to,\n    \"fee\": fee,\n    \"amount\": amount,\n    \"closeRemainderTo\": noCloseRemainder,\n    \"firstRound\": firstValid,\n    \"lastRound\": lastValid,\n    \"note\": noNote,\n    \"genesisHash\": genesisHash,\n    \"genesisID\": \"\",\n    \"type\": \"pay\",\n    \"lease\": lease\n  }; // check fee\n\n  let tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, \"\");\n\n  if (tempTxn.fee > ints[1]) {\n    throw new Error(\"final fee of payment transaction\" + tempTxn.fee.toString() + \"greater than transaction max fee\" + ints[1].toString());\n  }\n\n  return logicSig.signLogicSigTransaction(txn, lsig);\n}\n\nmodule.exports = {\n  PeriodicPayment,\n  getPeriodicPaymentWithdrawalTransaction\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/periodicpayment.js"],"names":["Buffer","require","address","makeTxn","logic","logicSig","nacl","templates","PeriodicPayment","constructor","receiver","amount","withdrawalWindow","period","expiryRound","maxFee","lease","Number","isSafeInteger","Error","undefined","leaseBytes","randomBytes","from","toString","programBytes","getProgram","lsig","LogicSig","referenceProgramB64","referenceProgramBytes","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","BASE64","ADDRESS","inject","getAddress","getPeriodicPaymentWithdrawalTransaction","contract","fee","firstValid","genesisHash","readResult","readProgram","ints","byteArrays","duration","receiverBytes","encodeAddress","leaseBuffer","Uint8Array","lastValid","to","noCloseRemainder","noNote","makeLogicSig","txn","tempTxn","makePaymentTxn","signLogicSigTransaction","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require(\"../encoding/address\");\nconst makeTxn = require('../makeTxn');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require(\"../nacl/naclWrappers\");\nconst templates = require('./templates');\n\nclass PeriodicPayment {\n    /**\n     * MakePeriodicPayment allows some account to execute periodic withdrawal of funds.\n     * This is a contract account.\n     *\n     * This allows receiver to withdraw amount every\n     * period rounds for withdrawWindow after every multiple\n     * of period.\n     *\n     * After expiryRound, all remaining funds in the escrow\n     * are available to receiver.\n     *\n     * Constructor Parameters:\n     * @param {string} receiver: address which is authorized to receive withdrawals\n     * @param {int} amount: the amount to send each period\n     * @param {int} withdrawalWindow: the duration of a withdrawal period\n     * @param {int} period: the time between a pair of withdrawal periods\n     * @param {int} expiryRound: the round at which the account expires\n     * @param {int} maxFee: maximum fee used by the withdrawal transaction\n     * @param {string} lease: b64 representation of lease to use, or leave undefined to generate one\n     * @returns {PeriodicPayment}\n     */\n    constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {\n        // don't need to validate receiver or lease, it's validated by template insert\n        this.receiver = receiver;\n        if (!Number.isSafeInteger(amount) || amount < 0) throw Error(\"amount must be a positive number and smaller than 2^53-1\");\n        this.amount = amount;\n        if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0) throw Error(\"withdrawalWindow must be a positive number and smaller than 2^53-1\");\n        this.withdrawalWindow = withdrawalWindow;\n        if (!Number.isSafeInteger(period) || period < 0) throw Error(\"period must be a positive number and smaller than 2^53-1\");\n        this.period = period;\n        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n        this.expiryRound = expiryRound;\n        if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n        this.maxFee = maxFee;\n\n        if (lease === undefined) {\n            let leaseBytes = nacl.randomBytes(32);\n            this.lease = Buffer.from(leaseBytes).toString('base64');\n        } else {\n            this.lease = lease\n        }\n\n        this.programBytes = this.getProgram();\n        let lsig = new logicSig.LogicSig( this.programBytes, undefined);\n        this.address = lsig.address();\n    }\n\n    /**\n     * returns the program bytes\n     * @returns {Uint8Array}\n     */\n    getProgram() {\n        const referenceProgramB64 = \"ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ\";\n        let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n        let referenceOffsets = [ /*fee*/ 4 /*period*/, 5 /*withdrawWindow*/, 7 /*amount*/, 8 /*expiryRound*/, 9 /*lease*/, 12 /*receiver*/, 46];\n        let injectionVector =  [this.maxFee, this.period, this.withdrawalWindow,\n            this.amount, this.expiryRound, this.lease,\n            this.receiver];\n        let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT,\n            templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.BASE64,\n            templates.valTypes.ADDRESS];\n        return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    }\n\n    /**\n     * returns the string address of the contract\n     * @returns {string}\n     */\n    getAddress() {\n        return this.address;\n    }\n\n}\n\n/**\n * getPeriodicPaymentWithdrawalTransaction returns a signed transaction extracting funds form the contract\n * @param {Uint8Array} contract: the bytearray defining the contract, received from the payer\n * @param {int} fee: the fee per byte for the transaction\n * @param {int} firstValid: the first round on which the txn will be valid\n * @param {string} genesisHash: the hash representing the network for the txn\n * @returns {Object} Object containing txID and blob representing signed transaction\n * @throws error on failure\n */\nfunction getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {\n    let readResult = logic.readProgram(contract, undefined);\n    let ints = readResult[0];\n    let byteArrays = readResult[1];\n    let period = ints[2];\n    let duration = ints[4];\n    let amount = ints[5];\n    if ((firstValid % period) !== 0) {\n        throw new Error(\"firstValid round \" + firstValid.toString() + \" was not a multiple of contract period \" + period.toString())\n    }\n\n    // extract receiver and convert as needed\n    let receiverBytes = byteArrays[1];\n    let receiver = address.encodeAddress(receiverBytes);\n    // extract lease and convert\n    let leaseBuffer = byteArrays[0];\n    let lease = new Uint8Array(leaseBuffer);\n    let lastValid = firstValid + duration;\n    let to = receiver;\n    let noCloseRemainder = undefined;\n    let noNote = undefined;\n    let lsig = logicSig.makeLogicSig(contract, undefined);\n    let from = lsig.address();\n    let txn = {\n        \"from\": from,\n        \"to\": to,\n        \"fee\": fee,\n        \"amount\": amount,\n        \"closeRemainderTo\": noCloseRemainder,\n        \"firstRound\": firstValid,\n        \"lastRound\": lastValid,\n        \"note\": noNote,\n        \"genesisHash\": genesisHash,\n        \"genesisID\": \"\",\n        \"type\": \"pay\",\n        \"lease\": lease\n    };\n\n    // check fee\n    let tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, \"\");\n    if (tempTxn.fee > ints[1]) {\n        throw new Error(\"final fee of payment transaction\" + tempTxn.fee.toString() + \"greater than transaction max fee\" + ints[1].toString())\n    }\n\n    return logicSig.signLogicSigTransaction(txn, lsig);\n}\nmodule.exports = {\n    PeriodicPayment,\n    getPeriodicPaymentWithdrawalTransaction\n};\n"]},"metadata":{},"sourceType":"script"}