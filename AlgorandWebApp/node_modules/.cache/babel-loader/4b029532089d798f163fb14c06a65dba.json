{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst client = require('./client');\n\nconst txn = require(\"../transaction\");\n\nfunction Kmd(token, baseServer = \"http://127.0.0.1\", port = 7833) {\n  // Get client\n  let c = new client.HTTPClient({\n    'X-KMD-API-Token': token\n  }, baseServer, port);\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   * @returns {Promise<*>}\n   */\n\n  this.versions = async function () {\n    let res = await c.get(\"/versions\");\n    return res.body;\n  };\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listWallets = async function () {\n    let res = await c.get(\"/v1/wallets\");\n    return res.body;\n  };\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   * @returns {Promise<*>}\n   */\n\n\n  this.createWallet = async function (walletName, walletPassword, walletMDK = \"\", walletDriverName = \"sqlite\") {\n    let req = {\n      \"wallet_name\": walletName,\n      \"wallet_driver_name\": walletDriverName,\n      \"wallet_password\": walletPassword,\n      \"master_derivation_key\": Buffer.from(walletMDK).toString('base64')\n    };\n    let res = await c.post(\"/v1/wallet\", req);\n    return res.body;\n  };\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.initWalletHandle = async function (walletID, walletPassword) {\n    let req = {\n      \"wallet_id\": walletID,\n      \"wallet_password\": walletPassword\n    };\n    let res = await c.post(\"/v1/wallet/init\", req);\n    return res.body;\n  };\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.releaseWalletHandle = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle\n    };\n    let res = await c.post(\"/v1/wallet/release\", req);\n    return res.body;\n  };\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.renewWalletHandle = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle\n    };\n    let res = await c.post(\"/v1/wallet/renew\", req);\n    return res.body;\n  };\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   * @returns {Promise<*>}\n   */\n\n\n  this.renameWallet = async function (walletID, walletPassword, newWalletName) {\n    let req = {\n      \"wallet_id\": walletID,\n      \"wallet_password\": walletPassword,\n      \"wallet_name\": newWalletName\n    };\n    let res = await c.post(\"/v1/wallet/rename\", req);\n    return res.body;\n  };\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.getWallet = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle\n    };\n    let res = await c.post(\"/v1/wallet/info\", req);\n    return res.body;\n  };\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMasterDerivationKey = async function (walletHandle, walletPassword) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"wallet_password\": walletPassword\n    };\n    let res = await c.post(\"/v1/master-key/export\", req);\n    return {\n      \"master_derivation_key\": Buffer.from(res.body.master_derivation_key, 'base64')\n    };\n  };\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   * @returns {Promise<*>}\n   */\n\n\n  this.importKey = async function (walletHandle, secretKey) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"private_key\": Buffer.from(secretKey).toString('base64')\n    };\n    let res = await c.post(\"/v1/key/import\", req);\n    return res.body;\n  };\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportKey = async function (walletHandle, walletPassword, addr) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"address\": addr,\n      \"wallet_password\": walletPassword\n    };\n    let res = await c.post(\"/v1/key/export\", req);\n    return {\n      \"private_key\": Buffer.from(res.body.private_key, 'base64')\n    };\n  };\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.generateKey = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"display_mnemonic\": false\n    };\n    let res = await c.post(\"/v1/key\", req);\n    return res.body;\n  };\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteKey = async function (walletHandle, walletPassword, addr) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"address\": addr,\n      \"wallet_password\": walletPassword\n    };\n    let res = await c.delete(\"/v1/key\", req);\n    return res.body;\n  };\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listKeys = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle\n    };\n    let res = await c.post(\"/v1/key/list\", req);\n    return res.body;\n  };\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @returns {Promise<*>}\n   */\n\n\n  this.signTransaction = async function (walletHandle, walletPassword, transaction) {\n    let tx = new txn.Transaction(transaction);\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"wallet_password\": walletPassword,\n      \"transaction\": Buffer.from(tx.toByte()).toString('base64')\n    };\n    let res = await c.post(\"/v1/transaction/sign\", req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n\n    return res.body;\n  };\n  /**\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * publicKey arg.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @param publicKey sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n   * @returns {Promise<*>}\n   */\n\n\n  this.signTransactionWithSpecificPublicKey = async function (walletHandle, walletPassword, transaction, publicKey) {\n    let tx = new txn.Transaction(transaction);\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"wallet_password\": walletPassword,\n      \"transaction\": Buffer.from(tx.toByte()).toString('base64'),\n      \"public_key\": Buffer.from(publicKey).toString('base64')\n    };\n    let res = await c.post(\"/v1/transaction/sign\", req);\n\n    if (res.statusCode === 200) {\n      return Buffer.from(res.body.signed_transaction, 'base64');\n    }\n\n    return res.body;\n  };\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listMultisig = async function (walletHandle) {\n    let req = {\n      \"wallet_handle_token\": walletHandle\n    };\n    let res = await c.post(\"/v1/multisig/list\", req);\n    return res.body;\n  };\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   * @returns {Promise<*>}\n   */\n\n\n  this.importMultisig = async function (walletHandle, version, threshold, pks) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"multisig_version\": version,\n      \"threshold\": threshold,\n      \"pks\": pks\n    };\n    let res = await c.post(\"/v1/multisig/import\", req);\n    return res.body;\n  };\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMultisig = async function (walletHandle, addr) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"address\": addr\n    };\n    let res = await c.post(\"/v1/multisig/export\", req);\n    return res.body;\n  };\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   * @returns {Promise<*>}\n   */\n\n\n  this.signMultisigTransaction = async function (walletHandle, pw, transaction, pk, partial) {\n    let tx = new txn.Transaction(transaction);\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"transaction\": Buffer.from(tx.toByte()).toString('base64'),\n      \"public_key\": Buffer.from(pk).toString('base64'),\n      \"partial_multisig\": partial,\n      \"wallet_password\": pw\n    };\n    let res = await c.post(\"/v1/multisig/sign\", req);\n    return res.body;\n  };\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the \n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteMultisig = async function (walletHandle, walletPassword, addr) {\n    let req = {\n      \"wallet_handle_token\": walletHandle,\n      \"address\": addr,\n      \"wallet_password\": walletPassword\n    };\n    let res = await c.delete(\"/v1/multisig\", req);\n    return res.body;\n  };\n}\n\nmodule.exports = {\n  Kmd\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/client/kmd.js"],"names":["Buffer","require","client","txn","Kmd","token","baseServer","port","c","HTTPClient","versions","res","get","body","listWallets","createWallet","walletName","walletPassword","walletMDK","walletDriverName","req","from","toString","post","initWalletHandle","walletID","releaseWalletHandle","walletHandle","renewWalletHandle","renameWallet","newWalletName","getWallet","exportMasterDerivationKey","master_derivation_key","importKey","secretKey","exportKey","addr","private_key","generateKey","deleteKey","delete","listKeys","signTransaction","transaction","tx","Transaction","toByte","statusCode","signed_transaction","signTransactionWithSpecificPublicKey","publicKey","listMultisig","importMultisig","version","threshold","pks","exportMultisig","signMultisigTransaction","pw","pk","partial","deleteMultisig","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,gBAAD,CAAnB;;AAEA,SAASG,GAAT,CAAaC,KAAb,EAAoBC,UAAU,GAAG,kBAAjC,EAAqDC,IAAI,GAAG,IAA5D,EAAkE;AAC9D;AACA,MAAIC,CAAC,GAAG,IAAIN,MAAM,CAACO,UAAX,CAAsB;AAAC,uBAAkBJ;AAAnB,GAAtB,EAAiDC,UAAjD,EAA6DC,IAA7D,CAAR;AAEA;AACJ;AACA;AACA;;AACI,OAAKG,QAAL,GAAgB,kBAAkB;AAC9B,QAAIC,GAAG,GAAG,MAAMH,CAAC,CAACI,GAAF,CAAM,WAAN,CAAhB;AACA,WAAOD,GAAG,CAACE,IAAX;AACH,GAHD;AAKA;AACJ;AACA;AACA;AACA;;;AACI,OAAKC,WAAL,GAAmB,kBAAkB;AACjC,QAAIH,GAAG,GAAG,MAAMH,CAAC,CAACI,GAAF,CAAM,aAAN,CAAhB;AACA,WAAOD,GAAG,CAACE,IAAX;AACH,GAHD;AAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKE,YAAL,GAAoB,gBAAgBC,UAAhB,EAA4BC,cAA5B,EAA4CC,SAAS,GAAG,EAAxD,EAA4DC,gBAAgB,GAAG,QAA/E,EAAyF;AACzG,QAAIC,GAAG,GAAG;AACN,qBAAeJ,UADT;AAEN,4BAAsBG,gBAFhB;AAGN,yBAAmBF,cAHb;AAIN,+BAAyBjB,MAAM,CAACqB,IAAP,CAAYH,SAAZ,EAAuBI,QAAvB,CAAgC,QAAhC;AAJnB,KAAV;AAMA,QAAIX,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,YAAP,EAAqBH,GAArB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GATD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKW,gBAAL,GAAwB,gBAAgBC,QAAhB,EAA0BR,cAA1B,EAA0C;AAC9D,QAAIG,GAAG,GAAG;AACN,mBAAaK,QADP;AAEN,yBAAmBR;AAFb,KAAV;AAKA,QAAIN,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,iBAAP,EAA0BH,GAA1B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GARD;AAUA;AACJ;AACA;AACA;AACA;AACA;;;AACI,OAAKa,mBAAL,GAA2B,gBAAgBC,YAAhB,EAA8B;AACrD,QAAIP,GAAG,GAAG;AACN,6BAAuBO;AADjB,KAAV;AAGA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,oBAAP,EAA6BH,GAA7B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAND;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKe,iBAAL,GAAyB,gBAAgBD,YAAhB,EAA8B;AACnD,QAAIP,GAAG,GAAG;AACN,6BAAuBO;AADjB,KAAV;AAGA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,kBAAP,EAA2BH,GAA3B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAND;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKgB,YAAL,GAAoB,gBAAgBJ,QAAhB,EAA0BR,cAA1B,EAA0Ca,aAA1C,EAAyD;AACzE,QAAIV,GAAG,GAAG;AACN,mBAAaK,QADP;AAEN,yBAAmBR,cAFb;AAGN,qBAAea;AAHT,KAAV;AAMA,QAAInB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,mBAAP,EAA4BH,GAA5B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GATD;AAWA;AACJ;AACA;AACA;AACA;AACA;;;AACI,OAAKkB,SAAL,GAAiB,gBAAgBJ,YAAhB,EAA8B;AAC3C,QAAIP,GAAG,GAAG;AACN,6BAAuBO;AADjB,KAAV;AAGA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,iBAAP,EAA0BH,GAA1B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAND;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKmB,yBAAL,GAAiC,gBAAgBL,YAAhB,EAA8BV,cAA9B,EAA8C;AAC3E,QAAIG,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,yBAAmBV;AAFb,KAAV;AAIA,QAAIN,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,uBAAP,EAAgCH,GAAhC,CAAhB;AACA,WAAO;AAAC,+BAAyBpB,MAAM,CAACqB,IAAP,CAAYV,GAAG,CAACE,IAAJ,CAASoB,qBAArB,EAA4C,QAA5C;AAA1B,KAAP;AACH,GAPD;AAUA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKC,SAAL,GAAiB,gBAAgBP,YAAhB,EAA8BQ,SAA9B,EAAyC;AACtD,QAAIf,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,qBAAe3B,MAAM,CAACqB,IAAP,CAAYc,SAAZ,EAAuBb,QAAvB,CAAgC,QAAhC;AAFT,KAAV;AAIA,QAAIX,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,gBAAP,EAAyBH,GAAzB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAPD;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKuB,SAAL,GAAiB,gBAAgBT,YAAhB,EAA8BV,cAA9B,EAA8CoB,IAA9C,EAAoD;AACjE,QAAIjB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,iBAAWU,IAFL;AAGN,yBAAmBpB;AAHb,KAAV;AAKA,QAAIN,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,gBAAP,EAAyBH,GAAzB,CAAhB;AACA,WAAO;AAAC,qBAAepB,MAAM,CAACqB,IAAP,CAAYV,GAAG,CAACE,IAAJ,CAASyB,WAArB,EAAkC,QAAlC;AAAhB,KAAP;AACH,GARD;AAUA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKC,WAAL,GAAmB,gBAAgBZ,YAAhB,EAA8B;AAC7C,QAAIP,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,0BAAoB;AAFd,KAAV;AAIA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,SAAP,EAAkBH,GAAlB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAPD;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAK2B,SAAL,GAAiB,gBAAgBb,YAAhB,EAA8BV,cAA9B,EAA8CoB,IAA9C,EAAoD;AACjE,QAAIjB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,iBAAWU,IAFL;AAGN,yBAAmBpB;AAHb,KAAV;AAKA,QAAIN,GAAG,GAAG,MAAMH,CAAC,CAACiC,MAAF,CAAS,SAAT,EAAoBrB,GAApB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GARD;AAUA;AACJ;AACA;AACA;AACA;AACA;;;AACI,OAAK6B,QAAL,GAAgB,gBAAgBf,YAAhB,EAA8B;AAC1C,QAAIP,GAAG,GAAG;AACN,6BAAuBO;AADjB,KAAV;AAGA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,cAAP,EAAuBH,GAAvB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAND;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAK8B,eAAL,GAAuB,gBAAgBhB,YAAhB,EAA8BV,cAA9B,EAA8C2B,WAA9C,EAA2D;AAE9E,QAAIC,EAAE,GAAG,IAAI1C,GAAG,CAAC2C,WAAR,CAAoBF,WAApB,CAAT;AAEA,QAAIxB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,yBAAmBV,cAFb;AAGN,qBAAejB,MAAM,CAACqB,IAAP,CAAYwB,EAAE,CAACE,MAAH,EAAZ,EAAyBzB,QAAzB,CAAkC,QAAlC;AAHT,KAAV;AAKA,QAAIX,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,sBAAP,EAA+BH,GAA/B,CAAhB;;AAEA,QAAIT,GAAG,CAACqC,UAAJ,KAAmB,GAAvB,EAA4B;AACxB,aAAOhD,MAAM,CAACqB,IAAP,CAAYV,GAAG,CAACE,IAAJ,CAASoC,kBAArB,EAAyC,QAAzC,CAAP;AACH;;AACD,WAAOtC,GAAG,CAACE,IAAX;AACH,GAfD;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKqC,oCAAL,GAA4C,gBAAgBvB,YAAhB,EAA8BV,cAA9B,EAA8C2B,WAA9C,EAA2DO,SAA3D,EAAsE;AAE9G,QAAIN,EAAE,GAAG,IAAI1C,GAAG,CAAC2C,WAAR,CAAoBF,WAApB,CAAT;AAEA,QAAIxB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,yBAAmBV,cAFb;AAGN,qBAAejB,MAAM,CAACqB,IAAP,CAAYwB,EAAE,CAACE,MAAH,EAAZ,EAAyBzB,QAAzB,CAAkC,QAAlC,CAHT;AAIN,oBAActB,MAAM,CAACqB,IAAP,CAAY8B,SAAZ,EAAuB7B,QAAvB,CAAgC,QAAhC;AAJR,KAAV;AAMA,QAAIX,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,sBAAP,EAA+BH,GAA/B,CAAhB;;AAEA,QAAIT,GAAG,CAACqC,UAAJ,KAAmB,GAAvB,EAA4B;AACxB,aAAOhD,MAAM,CAACqB,IAAP,CAAYV,GAAG,CAACE,IAAJ,CAASoC,kBAArB,EAAyC,QAAzC,CAAP;AACH;;AACD,WAAOtC,GAAG,CAACE,IAAX;AACH,GAhBD;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKuC,YAAL,GAAoB,gBAAgBzB,YAAhB,EAA8B;AAC9C,QAAIP,GAAG,GAAG;AACN,6BAAuBO;AADjB,KAAV;AAGA,QAAIhB,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,mBAAP,EAA4BH,GAA5B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAND;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKwC,cAAL,GAAsB,gBAAgB1B,YAAhB,EAA8B2B,OAA9B,EAAuCC,SAAvC,EAAkDC,GAAlD,EAAuD;AACzE,QAAIpC,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,0BAAoB2B,OAFd;AAGN,mBAAaC,SAHP;AAIN,aAAOC;AAJD,KAAV;AAMA,QAAI7C,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,qBAAP,EAA8BH,GAA9B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GATD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAK4C,cAAL,GAAsB,gBAAgB9B,YAAhB,EAA8BU,IAA9B,EAAoC;AACtD,QAAIjB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,iBAAWU;AAFL,KAAV;AAIA,QAAI1B,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,qBAAP,EAA8BH,GAA9B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAPD;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAK6C,uBAAL,GAA+B,gBAAgB/B,YAAhB,EAA8BgC,EAA9B,EAAkCf,WAAlC,EAA+CgB,EAA/C,EAAmDC,OAAnD,EAA4D;AACvF,QAAIhB,EAAE,GAAG,IAAI1C,GAAG,CAAC2C,WAAR,CAAoBF,WAApB,CAAT;AACA,QAAIxB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,qBAAe3B,MAAM,CAACqB,IAAP,CAAYwB,EAAE,CAACE,MAAH,EAAZ,EAAyBzB,QAAzB,CAAkC,QAAlC,CAFT;AAGN,oBAActB,MAAM,CAACqB,IAAP,CAAYuC,EAAZ,EAAgBtC,QAAhB,CAAyB,QAAzB,CAHR;AAIN,0BAAoBuC,OAJd;AAKN,yBAAmBF;AALb,KAAV;AAOA,QAAIhD,GAAG,GAAG,MAAMH,CAAC,CAACe,IAAF,CAAO,mBAAP,EAA4BH,GAA5B,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GAXD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,OAAKiD,cAAL,GAAsB,gBAAgBnC,YAAhB,EAA8BV,cAA9B,EAA8CoB,IAA9C,EAAoD;AACtE,QAAIjB,GAAG,GAAG;AACN,6BAAuBO,YADjB;AAEN,iBAAWU,IAFL;AAGN,yBAAmBpB;AAHb,KAAV;AAKA,QAAIN,GAAG,GAAG,MAAMH,CAAC,CAACiC,MAAF,CAAS,cAAT,EAAyBrB,GAAzB,CAAhB;AACA,WAAOT,GAAG,CAACE,IAAX;AACH,GARD;AASH;;AACDkD,MAAM,CAACC,OAAP,GAAiB;AAAC5D,EAAAA;AAAD,CAAjB","sourcesContent":["const { Buffer } = require('buffer');\nconst client = require('./client');\nconst txn = require(\"../transaction\");\n\nfunction Kmd(token, baseServer = \"http://127.0.0.1\", port = 7833) {\n    // Get client\n    let c = new client.HTTPClient({'X-KMD-API-Token':token}, baseServer, port);\n\n    /**\n     * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n     * @returns {Promise<*>}\n     */\n    this.versions = async function () {\n        let res = await c.get(\"/versions\");\n        return res.body;\n    };\n\n    /**\n     * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n     * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n     * @returns {Promise<*>}\n     */\n    this.listWallets = async function () {\n        let res = await c.get(\"/v1/wallets\");\n        return res.body;\n    };\n\n    /**\n     * createWallet creates a wallet with the specified name, password, driver,\n     * and master derivation key. If the master derivation key is blank, one is\n     * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n     * containing information about the new wallet.\n     * @param walletName\n     * @param walletPassword\n     * @param walletDriverName\n     * @param walletMDK\n     * @returns {Promise<*>}\n     */\n    this.createWallet = async function (walletName, walletPassword, walletMDK = \"\", walletDriverName = \"sqlite\") {\n        let req = {\n            \"wallet_name\": walletName,\n            \"wallet_driver_name\": walletDriverName,\n            \"wallet_password\": walletPassword,\n            \"master_derivation_key\": Buffer.from(walletMDK).toString('base64'),\n        };\n        let res = await c.post(\"/v1/wallet\", req);\n        return res.body;\n    };\n\n    /**\n     * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n     * initWalletHandleResponse containing a wallet handle token. This wallet\n     * handle token can be used for subsequent operations on this wallet, like key\n     * generation, transaction signing, etc.. WalletHandleTokens expire after a\n     * configurable number of seconds, and must be renewed periodically with\n     * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n     * you're done interacting with this wallet.\n     * @param walletID\n     * @param walletPassword\n     * @returns {Promise<*>}\n     */\n    this.initWalletHandle = async function (walletID, walletPassword) {\n        let req = {\n            \"wallet_id\": walletID,\n            \"wallet_password\": walletPassword,\n\n        };\n        let res = await c.post(\"/v1/wallet/init\", req);\n        return res.body;\n    };\n\n    /**\n     * releaseWalletHandle invalidates the passed wallet handle token, making\n     * it unusuable for subsequent wallet operations.\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.releaseWalletHandle = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n        };\n        let res = await c.post(\"/v1/wallet/release\", req);\n        return res.body;\n    };\n\n    /**\n     * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n     * the expiration time to some number of seconds in the future. It returns a\n     * RenewWalletHandleResponse containing the walletHandle and the number of\n     * seconds until expiration\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.renewWalletHandle = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n        };\n        let res = await c.post(\"/v1/wallet/renew\", req);\n        return res.body;\n    };\n\n    /**\n     * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n     * and renames the underlying wallet.\n     * @param walletID\n     * @param walletPassword\n     * @param newWalletName\n     * @returns {Promise<*>}\n     */\n    this.renameWallet = async function (walletID, walletPassword, newWalletName) {\n        let req = {\n            \"wallet_id\": walletID,\n            \"wallet_password\": walletPassword,\n            \"wallet_name\": newWalletName\n\n        };\n        let res = await c.post(\"/v1/wallet/rename\", req);\n        return res.body;\n    };\n\n    /**\n     * getWallet accepts a wallet handle and returns high level information about\n     * this wallet in a GetWalletResponse.\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.getWallet = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n        };\n        let res = await c.post(\"/v1/wallet/info\", req);\n        return res.body;\n    };\n\n    /**\n     * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n     * returns an ExportMasterDerivationKeyResponse containing the master\n     * derivation key. This key can be used as an argument to CreateWallet in\n     * order to recover the keys generated by this wallet. The master derivation\n     * key can be encoded as a sequence of words using the mnemonic library, and\n     * @param walletHandle\n     * @param walletPassword\n     * @returns {Promise<*>}\n     */\n    this.exportMasterDerivationKey = async function (walletHandle, walletPassword) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"wallet_password\": walletPassword,\n        };\n        let res = await c.post(\"/v1/master-key/export\", req);\n        return {\"master_derivation_key\": Buffer.from(res.body.master_derivation_key, 'base64')};\n    };\n\n\n    /**\n     * importKey accepts a wallet handle and an ed25519 private key, and imports\n     * the key into the wallet. It returns an ImportKeyResponse containing the\n     * address corresponding to this private key.\n     * @param walletHandle\n     * @param secretKey\n     * @returns {Promise<*>}\n     */\n    this.importKey = async function (walletHandle, secretKey) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"private_key\": Buffer.from(secretKey).toString('base64'),\n        };\n        let res = await c.post(\"/v1/key/import\", req);\n        return res.body;\n    };\n\n    /**\n     * exportKey accepts a wallet handle, wallet password, and address, and returns\n     * an ExportKeyResponse containing the ed25519 private key corresponding to the\n     * address stored in the wallet.\n     * @param walletHandle\n     * @param walletPassword\n     * @param addr\n     * @returns {Promise<*>}\n     */\n    this.exportKey = async function (walletHandle, walletPassword, addr) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"address\": addr,\n            \"wallet_password\": walletPassword\n        };\n        let res = await c.post(\"/v1/key/export\", req);\n        return {\"private_key\": Buffer.from(res.body.private_key, 'base64')};\n    };\n\n    /**\n     * generateKey accepts a wallet handle, and then generates the next key in the\n     * wallet using its internal master derivation key. Two wallets with the same\n     * master derivation key will generate the same sequence of keys.\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.generateKey = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"display_mnemonic\": false\n        };\n        let res = await c.post(\"/v1/key\", req);\n        return res.body;\n    };\n\n    /**\n     * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n     * the information about this address from the wallet (including address and\n     * secret key). If DeleteKey is called on a key generated using GenerateKey,\n     * the same key will not be generated again. However, if a wallet is recovered\n     * using the master derivation key, a key generated in this way can be\n     * recovered.\n     * @param walletHandle\n     * @param walletPassword\n     * @param addr\n     * @returns {Promise<*>}\n     */\n    this.deleteKey = async function (walletHandle, walletPassword, addr) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"address\": addr,\n            \"wallet_password\": walletPassword\n        };\n        let res = await c.delete(\"/v1/key\", req);\n        return res.body;\n    };\n\n    /**\n     * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n     * all of the addresses for which this wallet contains secret keys.\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.listKeys = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n        };\n        let res = await c.post(\"/v1/key/list\", req);\n        return res.body;\n    };\n\n    /**\n     * signTransaction accepts a wallet handle, wallet password, and a transaction,\n     * and returns and SignTransactionResponse containing an encoded, signed\n     * transaction. The transaction is signed using the key corresponding to the\n     * Sender field.\n     * @param walletHandle\n     * @param walletPassword\n     * @param transaction\n     * @returns {Promise<*>}\n     */\n    this.signTransaction = async function (walletHandle, walletPassword, transaction) {\n\n        let tx = new txn.Transaction(transaction);\n\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"wallet_password\": walletPassword,\n            \"transaction\": Buffer.from(tx.toByte()).toString('base64')\n        };\n        let res = await c.post(\"/v1/transaction/sign\", req);\n\n        if (res.statusCode === 200) {\n            return Buffer.from(res.body.signed_transaction, 'base64')\n        }\n        return res.body;\n    };\n\n    /**\n     * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n     * and returns and SignTransactionResponse containing an encoded, signed\n     * transaction. The transaction is signed using the key corresponding to the\n     * publicKey arg.\n     * @param walletHandle\n     * @param walletPassword\n     * @param transaction\n     * @param publicKey sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n     * @returns {Promise<*>}\n     */\n    this.signTransactionWithSpecificPublicKey = async function (walletHandle, walletPassword, transaction, publicKey) {\n\n        let tx = new txn.Transaction(transaction);\n\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"wallet_password\": walletPassword,\n            \"transaction\": Buffer.from(tx.toByte()).toString('base64'),\n            \"public_key\": Buffer.from(publicKey).toString('base64')\n        };\n        let res = await c.post(\"/v1/transaction/sign\", req);\n\n        if (res.statusCode === 200) {\n            return Buffer.from(res.body.signed_transaction, 'base64')\n        }\n        return res.body;\n    };\n    /**\n     * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n     * containing the multisig addresses whose preimages are stored in this wallet.\n     * A preimage is the information needed to reconstruct this multisig address,\n     * including multisig version information, threshold information, and a list\n     * of public keys.\n     * @param walletHandle\n     * @returns {Promise<*>}\n     */\n    this.listMultisig = async function (walletHandle) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n        };\n        let res = await c.post(\"/v1/multisig/list\", req);\n        return res.body;\n    };\n\n    /**\n     * importMultisig accepts a wallet handle and the information required to\n     * generate a multisig address. It derives this address, and stores all of the\n     * information within the wallet. It returns a ImportMultisigResponse with the\n     * derived address.\n     * @param walletHandle\n     * @param version\n     * @param threshold\n     * @param pks\n     * @returns {Promise<*>}\n     */\n    this.importMultisig = async function (walletHandle, version, threshold, pks) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"multisig_version\": version,\n            \"threshold\": threshold,\n            \"pks\": pks\n        };\n        let res = await c.post(\"/v1/multisig/import\", req);\n        return res.body;\n    };\n\n    /**\n     * exportMultisig accepts a wallet handle, wallet password, and multisig\n     * address, and returns an ExportMultisigResponse containing the stored\n     * multisig preimage. The preimage contains all of the information necessary\n     * to derive the multisig address, including version, threshold, and a list of\n     * public keys.\n     * @param walletHandle\n     * @param walletPassword\n     * @param addr\n     * @returns {Promise<*>}\n     */\n    this.exportMultisig = async function (walletHandle, addr) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"address\": addr,\n        };\n        let res = await c.post(\"/v1/multisig/export\", req);\n        return res.body;\n    };\n\n    /**\n     * signMultisigTransaction accepts a wallet handle, wallet password,\n     * transaction, public key (*not* an address), and an optional partial\n     * MultisigSig. It looks up the secret key corresponding to the public key, and\n     * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n     * signature by the secret key included.\n     * @param walletHandle\n     * @param pw\n     * @param tx\n     * @param pk\n     * @param partial\n     * @returns {Promise<*>}\n     */\n    this.signMultisigTransaction = async function (walletHandle, pw, transaction, pk, partial) {\n        let tx = new txn.Transaction(transaction);\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"transaction\": Buffer.from(tx.toByte()).toString('base64'),\n            \"public_key\": Buffer.from(pk).toString('base64'),\n            \"partial_multisig\": partial,\n            \"wallet_password\": pw\n        };\n        let res = await c.post(\"/v1/multisig/sign\", req);\n        return res.body;\n    };\n\n    /**\n     * deleteMultisig accepts a wallet handle, wallet password, and multisig\n     * address, and deletes the information about this multisig address from the \n     * wallet (including address and secret key).\n     * @param walletHandle\n     * @param walletPassword\n     * @param addr\n     * @returns {Promise<*>}\n     */\n    this.deleteMultisig = async function (walletHandle, walletPassword, addr) {\n        let req = {\n            \"wallet_handle_token\": walletHandle,\n            \"address\": addr,\n            \"wallet_password\": walletPassword\n        };\n        let res = await c.delete(\"/v1/multisig\", req);\n        return res.body;\n    };\n}\nmodule.exports = {Kmd};"]},"metadata":{},"sourceType":"script"}