{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst address = require('../encoding/address');\n\nconst makeTxn = require('../makeTxn');\n\nconst group = require('../group');\n\nconst logicsig = require('../logicsig');\n\nconst logic = require('../logic/logic');\n\nconst templates = require('./templates');\n\nconst utils = require('../utils/utils');\n\nclass Split {\n  /**\n  * Split splits money sent to some account to two recipients at some ratio.\n  * This is a contract account.\n  *\n  * This allows either a two-transaction group, for executing a\n  * split, or single transaction, for closing the account.\n  *\n  * Withdrawals from this account are allowed as a group transaction which\n  * sends receiverOne and receiverTwo amounts with exactly the specified ratio:\n  * (rat1*amountForReceiverOne) = (rat2*amountForReceiverTwo)\n  * At least minPay must be sent to receiverOne.\n  * (CloseRemainderTo must be zero.)\n  *\n  * After expiryRound passes, all funds can be refunded to owner.\n  * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {string} receiverOne: the first recipient in the split account\n   * @param {string} receiverTwo: the second recipient in the split account\n   * @param {int} rat1: fraction of money to be paid to the 1st recipient\n   * @param {int} rat2: fraction of money to be paid to the 2nd recipient\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minPay: minimum amount to be paid out of the account\n   * @param {int} maxFee: half of the maximum fee used by each split forwarding group transaction\n   * @returns {Split}\n   */\n  constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {\n    // don't need to validate owner, receiverone, receivertwo - they'll be validated by template.insert\n    if (!Number.isSafeInteger(rat2) || rat2 < 0) throw Error(\"rat2 must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(rat1) || rat1 < 0) throw Error(\"rat1 must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(minPay) || minPay < 0) throw Error(\"minPay must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n    const referenceProgramB64 = \"ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=\";\n    let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    let referenceOffsets = [\n    /*fee*/\n    4\n    /*timeout*/\n    , 7\n    /*rat2*/\n    , 8\n    /*rat1*/\n    , 9\n    /*minPay*/\n    , 10\n    /*owner*/\n    , 14\n    /*receiver1*/\n    , 47\n    /*receiver2*/\n    , 80];\n    let injectionVector = [maxFee, expiryRound, rat2, rat1, minPay, owner, receiverOne, receiverTwo];\n    let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS];\n    let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    let lsig = logicsig.makeLogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n\n\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n\n\n  getAddress() {\n    return this.address;\n  }\n\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: bytes representing the contract in question\n * @param {int} amount: the amount to be transferred\n * @param {int} firstRound: the first round on which the transaction group will be valid\n * @param {int} lastRound: the last round on which the transaction group will be valid\n * @param {int} fee: the fee to pay in microAlgos\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n */\n\n\nfunction getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {\n  let programOutputs = logic.readProgram(contract, undefined);\n  let ints = programOutputs[0];\n  let byteArrays = programOutputs[1];\n  let rat2 = ints[6];\n  let rat1 = ints[5];\n  let amountForReceiverOne = 0; // reduce fractions\n\n  let gcdFn = function (a, b) {\n    if (typeof a !== 'number' || typeof b !== 'number') throw \"gcd operates only on positive integers\";\n\n    if (!b) {\n      return a;\n    }\n\n    return gcdFn(b, a % b);\n  };\n\n  let gcd = gcdFn(rat2, rat1);\n  rat2 = Math.floor(rat2 / gcd);\n  rat1 = Math.floor(rat1 / gcd);\n  let ratio = rat1 / rat2;\n  amountForReceiverOne = Math.round(amount / (1 + ratio));\n  let amountForReceiverTwo = amount - amountForReceiverOne;\n\n  if (rat1 * amountForReceiverOne != rat2 * amountForReceiverTwo) {\n    throw Error(\"could not split funds in a way that satisfied the contract ratio\");\n  }\n\n  let logicSig = logicsig.makeLogicSig(contract, undefined); // no args\n\n  let from = logicSig.address();\n  let receiverOne = address.encodeAddress(byteArrays[1]);\n  let receiverTwo = address.encodeAddress(byteArrays[2]);\n  let tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, undefined, firstRound, lastRound, undefined, genesisHash);\n  let tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, undefined, firstRound, lastRound, undefined, genesisHash);\n  let txns = [tx1, tx2];\n  let txGroup = group.assignGroupID(txns);\n  let signedTxns = [];\n\n  for (let idx in txGroup) {\n    let stxn = logicsig.signLogicSigTransactionObject(txGroup[idx], logicSig);\n    signedTxns.push(stxn.blob);\n  }\n\n  return utils.concatArrays(signedTxns[0], signedTxns[1]);\n}\n\nmodule.exports = {\n  Split,\n  getSplitFundsTransaction\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logicTemplates/split.js"],"names":["Buffer","require","address","makeTxn","group","logicsig","logic","templates","utils","Split","constructor","owner","receiverOne","receiverTwo","rat1","rat2","expiryRound","minPay","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","makeLogicSig","undefined","getProgram","getAddress","getSplitFundsTransaction","contract","amount","firstRound","lastRound","fee","genesisHash","programOutputs","readProgram","ints","byteArrays","amountForReceiverOne","gcdFn","a","b","gcd","Math","floor","ratio","round","amountForReceiverTwo","logicSig","encodeAddress","tx1","makePaymentTxn","tx2","txns","txGroup","assignGroupID","signedTxns","idx","stxn","signLogicSigTransactionObject","push","blob","concatArrays","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,gBAAD,CAArB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,gBAAD,CAArB;;AAEA,MAAMQ,KAAN,CAAY;AACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,KAAD,EAAQC,WAAR,EAAqBC,WAArB,EAAkCC,IAAlC,EAAwCC,IAAxC,EAA8CC,WAA9C,EAA2DC,MAA3D,EAAmEC,MAAnE,EAA2E;AAClF;AACA,QAAI,CAACC,MAAM,CAACC,aAAP,CAAqBL,IAArB,CAAD,IAA+BA,IAAI,GAAG,CAA1C,EAA6C,MAAMM,KAAK,CAAC,wDAAD,CAAX;AAC7C,QAAI,CAACF,MAAM,CAACC,aAAP,CAAqBN,IAArB,CAAD,IAA+BA,IAAI,GAAG,CAA1C,EAA6C,MAAMO,KAAK,CAAC,wDAAD,CAAX;AAC7C,QAAI,CAACF,MAAM,CAACC,aAAP,CAAqBJ,WAArB,CAAD,IAAsCA,WAAW,GAAG,CAAxD,EAA2D,MAAMK,KAAK,CAAC,+DAAD,CAAX;AAC3D,QAAI,CAACF,MAAM,CAACC,aAAP,CAAqBH,MAArB,CAAD,IAAiCA,MAAM,GAAG,CAA9C,EAAiD,MAAMI,KAAK,CAAC,0DAAD,CAAX;AACjD,QAAI,CAACF,MAAM,CAACC,aAAP,CAAqBF,MAArB,CAAD,IAAiCA,MAAM,GAAG,CAA9C,EAAiD,MAAMG,KAAK,CAAC,0DAAD,CAAX;AAEjD,UAAMC,mBAAmB,GAAG,8QAA5B;AACA,QAAIC,qBAAqB,GAAGvB,MAAM,CAACwB,IAAP,CAAYF,mBAAZ,EAAiC,QAAjC,CAA5B;AACA,QAAIG,gBAAgB,GAAG;AAAE;AAAQ;AAAE;AAAZ,MAAyB;AAAE;AAA3B,MAAqC;AAAE;AAAvC,MAAiD;AAAE;AAAnD,MAA+D;AAAG;AAAlE,MAA6E;AAAG;AAAhF,MAA+F;AAAG;AAAlG,MAAiH,EAAjH,CAAvB;AACA,QAAIC,eAAe,GAAI,CAACR,MAAD,EAASF,WAAT,EAAsBD,IAAtB,EAA4BD,IAA5B,EAAkCG,MAAlC,EAA0CN,KAA1C,EAAiDC,WAAjD,EAA8DC,WAA9D,CAAvB;AACA,QAAIc,cAAc,GAAG,CAACpB,SAAS,CAACqB,QAAV,CAAmBC,GAApB,EAAyBtB,SAAS,CAACqB,QAAV,CAAmBC,GAA5C,EAAiDtB,SAAS,CAACqB,QAAV,CAAmBC,GAApE,EAAyEtB,SAAS,CAACqB,QAAV,CAAmBC,GAA5F,EAAiGtB,SAAS,CAACqB,QAAV,CAAmBC,GAApH,EAAyHtB,SAAS,CAACqB,QAAV,CAAmBE,OAA5I,EAAqJvB,SAAS,CAACqB,QAAV,CAAmBE,OAAxK,EAAiLvB,SAAS,CAACqB,QAAV,CAAmBE,OAApM,CAArB;AACA,QAAIC,aAAa,GAAGxB,SAAS,CAACyB,MAAV,CAAiBT,qBAAjB,EAAwCE,gBAAxC,EAA0DC,eAA1D,EAA2EC,cAA3E,CAApB;AACA,SAAKM,YAAL,GAAoBF,aAApB;AACA,QAAIG,IAAI,GAAG7B,QAAQ,CAAC8B,YAAT,CAAsBJ,aAAtB,EAAqCK,SAArC,CAAX;AACA,SAAKlC,OAAL,GAAegC,IAAI,CAAChC,OAAL,EAAf;AACH;AAED;AACJ;AACA;AACA;;;AACKmC,EAAAA,UAAU,GAAG;AACV,WAAO,KAAKJ,YAAZ;AACH;AAED;AACJ;AACA;AACA;;;AACIK,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKpC,OAAZ;AACH;;AA3DO;AA8DZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqC,wBAAT,CAAkCC,QAAlC,EAA4CC,MAA5C,EAAoDC,UAApD,EAAgEC,SAAhE,EAA2EC,GAA3E,EAAgFC,WAAhF,EAA6F;AACzF,MAAIC,cAAc,GAAGxC,KAAK,CAACyC,WAAN,CAAkBP,QAAlB,EAA4BJ,SAA5B,CAArB;AACA,MAAIY,IAAI,GAAGF,cAAc,CAAC,CAAD,CAAzB;AACA,MAAIG,UAAU,GAAGH,cAAc,CAAC,CAAD,CAA/B;AACA,MAAI/B,IAAI,GAAGiC,IAAI,CAAC,CAAD,CAAf;AACA,MAAIlC,IAAI,GAAGkC,IAAI,CAAC,CAAD,CAAf;AACA,MAAIE,oBAAoB,GAAG,CAA3B,CANyF,CAOzF;;AACA,MAAIC,KAAK,GAAG,UAASC,CAAT,EAAYC,CAAZ,EAAe;AACvB,QAAK,OAAOD,CAAP,KAAa,QAAd,IAA4B,OAAOC,CAAP,KAAa,QAA7C,EAAwD,MAAM,wCAAN;;AACxD,QAAI,CAACA,CAAL,EAAQ;AACJ,aAAOD,CAAP;AACH;;AACD,WAAOD,KAAK,CAACE,CAAD,EAAID,CAAC,GAAGC,CAAR,CAAZ;AACH,GAND;;AAOA,MAAIC,GAAG,GAAGH,KAAK,CAACpC,IAAD,EAAOD,IAAP,CAAf;AACAC,EAAAA,IAAI,GAAGwC,IAAI,CAACC,KAAL,CAAWzC,IAAI,GAAGuC,GAAlB,CAAP;AACAxC,EAAAA,IAAI,GAAGyC,IAAI,CAACC,KAAL,CAAW1C,IAAI,GAAGwC,GAAlB,CAAP;AACA,MAAIG,KAAK,GAAG3C,IAAI,GAAGC,IAAnB;AACAmC,EAAAA,oBAAoB,GAAGK,IAAI,CAACG,KAAL,CAAWjB,MAAM,IAAI,IAAIgB,KAAR,CAAjB,CAAvB;AACA,MAAIE,oBAAoB,GAAGlB,MAAM,GAAGS,oBAApC;;AACA,MAAKpC,IAAI,GAACoC,oBAAN,IAAgCnC,IAAI,GAAC4C,oBAAzC,EAAgE;AAC5D,UAAMtC,KAAK,CAAC,kEAAD,CAAX;AACH;;AAED,MAAIuC,QAAQ,GAAGvD,QAAQ,CAAC8B,YAAT,CAAsBK,QAAtB,EAAgCJ,SAAhC,CAAf,CAzByF,CAyB9B;;AAC3D,MAAIZ,IAAI,GAAGoC,QAAQ,CAAC1D,OAAT,EAAX;AACA,MAAIU,WAAW,GAAGV,OAAO,CAAC2D,aAAR,CAAsBZ,UAAU,CAAC,CAAD,CAAhC,CAAlB;AACA,MAAIpC,WAAW,GAAGX,OAAO,CAAC2D,aAAR,CAAsBZ,UAAU,CAAC,CAAD,CAAhC,CAAlB;AACA,MAAIa,GAAG,GAAG3D,OAAO,CAAC4D,cAAR,CAAuBvC,IAAvB,EAA6BZ,WAA7B,EAA0CgC,GAA1C,EAA+CM,oBAA/C,EAAqEd,SAArE,EAAgFM,UAAhF,EAA4FC,SAA5F,EAAuGP,SAAvG,EAAkHS,WAAlH,CAAV;AACA,MAAImB,GAAG,GAAG7D,OAAO,CAAC4D,cAAR,CAAuBvC,IAAvB,EAA6BX,WAA7B,EAA0C+B,GAA1C,EAA+Ce,oBAA/C,EAAqEvB,SAArE,EAAgFM,UAAhF,EAA4FC,SAA5F,EAAuGP,SAAvG,EAAkHS,WAAlH,CAAV;AACA,MAAIoB,IAAI,GAAG,CAACH,GAAD,EAAME,GAAN,CAAX;AACA,MAAIE,OAAO,GAAG9D,KAAK,CAAC+D,aAAN,CAAoBF,IAApB,CAAd;AAEA,MAAIG,UAAU,GAAG,EAAjB;;AACA,OAAK,IAAIC,GAAT,IAAgBH,OAAhB,EAAyB;AACrB,QAAII,IAAI,GAAGjE,QAAQ,CAACkE,6BAAT,CAAuCL,OAAO,CAACG,GAAD,CAA9C,EAAqDT,QAArD,CAAX;AACAQ,IAAAA,UAAU,CAACI,IAAX,CAAgBF,IAAI,CAACG,IAArB;AACH;;AACD,SAAOjE,KAAK,CAACkE,YAAN,CAAmBN,UAAU,CAAC,CAAD,CAA7B,EAAkCA,UAAU,CAAC,CAAD,CAA5C,CAAP;AACH;;AAEDO,MAAM,CAACC,OAAP,GAAiB;AACbnE,EAAAA,KADa;AAEb8B,EAAAA;AAFa,CAAjB","sourcesContent":["const { Buffer } = require('buffer');\nconst address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logicsig = require('../logicsig');\nconst logic = require('../logic/logic');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\n\nclass Split {\n    /**\n    * Split splits money sent to some account to two recipients at some ratio.\n    * This is a contract account.\n    *\n    * This allows either a two-transaction group, for executing a\n    * split, or single transaction, for closing the account.\n    *\n    * Withdrawals from this account are allowed as a group transaction which\n    * sends receiverOne and receiverTwo amounts with exactly the specified ratio:\n    * (rat1*amountForReceiverOne) = (rat2*amountForReceiverTwo)\n    * At least minPay must be sent to receiverOne.\n    * (CloseRemainderTo must be zero.)\n    *\n    * After expiryRound passes, all funds can be refunded to owner.\n    * Constructor Parameters:\n     * @param {string} owner: the address to refund funds to on timeout\n     * @param {string} receiverOne: the first recipient in the split account\n     * @param {string} receiverTwo: the second recipient in the split account\n     * @param {int} rat1: fraction of money to be paid to the 1st recipient\n     * @param {int} rat2: fraction of money to be paid to the 2nd recipient\n     * @param {int} expiryRound: the round at which the account expires\n     * @param {int} minPay: minimum amount to be paid out of the account\n     * @param {int} maxFee: half of the maximum fee used by each split forwarding group transaction\n     * @returns {Split}\n     */\n    constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {\n        // don't need to validate owner, receiverone, receivertwo - they'll be validated by template.insert\n        if (!Number.isSafeInteger(rat2) || rat2 < 0) throw Error(\"rat2 must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(rat1) || rat1 < 0) throw Error(\"rat1 must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error(\"expiryRound must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(minPay) || minPay < 0) throw Error(\"minPay must be a positive number and smaller than 2^53-1\");\n        if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error(\"maxFee must be a positive number and smaller than 2^53-1\");\n\n        const referenceProgramB64 = \"ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=\";\n        let referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n        let referenceOffsets = [ /*fee*/ 4 /*timeout*/, 7 /*rat2*/, 8 /*rat1*/, 9 /*minPay*/, 10 /*owner*/, 14 /*receiver1*/, 47 /*receiver2*/, 80];\n        let injectionVector =  [maxFee, expiryRound, rat2, rat1, minPay, owner, receiverOne, receiverTwo];\n        let injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS];\n        let injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n        this.programBytes = injectedBytes;\n        let lsig = logicsig.makeLogicSig(injectedBytes, undefined);\n        this.address = lsig.address();\n    }\n\n    /**\n     * returns the program bytes\n     * @returns {Uint8Array}\n     */\n     getProgram() {\n        return this.programBytes;\n    }\n\n    /**\n     * returns the string address of the contract\n     * @returns {string}\n     */\n    getAddress() {\n        return this.address;\n    }\n\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n * @param {Uint8Array} contract: bytes representing the contract in question\n * @param {int} amount: the amount to be transferred\n * @param {int} firstRound: the first round on which the transaction group will be valid\n * @param {int} lastRound: the last round on which the transaction group will be valid\n * @param {int} fee: the fee to pay in microAlgos\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n */\nfunction getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {\n    let programOutputs = logic.readProgram(contract, undefined);\n    let ints = programOutputs[0];\n    let byteArrays = programOutputs[1];\n    let rat2 = ints[6];\n    let rat1 = ints[5];\n    let amountForReceiverOne = 0;\n    // reduce fractions\n    let gcdFn = function(a, b) {\n        if ((typeof a !== 'number') || (typeof b !== 'number')) throw \"gcd operates only on positive integers\";\n        if (!b) {\n            return a;\n        }\n        return gcdFn(b, a % b);\n    };\n    let gcd = gcdFn(rat2, rat1);\n    rat2 = Math.floor(rat2 / gcd);\n    rat1 = Math.floor(rat1 / gcd);\n    let ratio = rat1 / rat2;\n    amountForReceiverOne = Math.round(amount / (1 + ratio));\n    let amountForReceiverTwo = amount - amountForReceiverOne;\n    if ((rat1*amountForReceiverOne) != (rat2*amountForReceiverTwo)) {\n        throw Error(\"could not split funds in a way that satisfied the contract ratio\");\n    }\n\n    let logicSig = logicsig.makeLogicSig(contract, undefined); // no args\n    let from = logicSig.address();\n    let receiverOne = address.encodeAddress(byteArrays[1]);\n    let receiverTwo = address.encodeAddress(byteArrays[2]);\n    let tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, undefined, firstRound, lastRound, undefined, genesisHash);\n    let tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, undefined, firstRound, lastRound, undefined, genesisHash);\n    let txns = [tx1, tx2];\n    let txGroup = group.assignGroupID(txns);\n\n    let signedTxns = [];\n    for (let idx in txGroup) {\n        let stxn = logicsig.signLogicSigTransactionObject(txGroup[idx], logicSig);\n        signedTxns.push(stxn.blob)\n    }\n    return utils.concatArrays(signedTxns[0], signedTxns[1]);\n}\n\nmodule.exports = {\n    Split,\n    getSplitFundsTransaction\n};\n"]},"metadata":{},"sourceType":"script"}