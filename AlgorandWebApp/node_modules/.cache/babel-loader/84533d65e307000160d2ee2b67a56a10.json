{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst encoding = require('./encoding/encoding');\n\nconst txnBuilder = require('./transaction');\n\nconst utils = require('./utils/utils');\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\n\nconst ERROR_MULTISIG_MERGE_LESSTHANTWO = new Error(\"Not enough multisig transactions to merge. Need at least two\");\nconst ERROR_MULTISIG_MERGE_MISMATCH = new Error(\"Cannot merge txs. txIDs differ\");\nconst ERROR_MULTISIG_MERGE_WRONG_PREIMAGE = new Error(\"Cannot merge txs. Multisig preimages differ\");\nconst ERROR_MULTISIG_MERGE_SIG_MISMATCH = new Error(\"Cannot merge txs. subsigs are mismatched.\");\nconst ERROR_MULTISIG_BAD_FROM_FIELD = new Error(\"The transaction from field and multisig preimage do not match.\");\nconst ERROR_MULTISIG_KEY_NOT_EXIST = new Error(\"Key does not exist\");\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\n\nclass MultisigTransaction extends txnBuilder.Transaction {\n  get_obj_for_encoding() {\n    if (this.hasOwnProperty(\"objForEncoding\")) {\n      // if set, use the value for encoding. This allows us to sign existing non-payment type transactions.\n      return this.objForEncoding;\n    }\n\n    return super.get_obj_for_encoding();\n  }\n\n  static from_obj_for_encoding(txnForEnc) {\n    if (txnForEnc.type !== \"pay\") {\n      // we don't support decoding this txn yet - but we can keep signing it since we have the\n      // encoded format. We trust that the caller knows what they are trying to sign.\n      let txn = Object.create(this.prototype);\n      txn.name = \"Transaction\";\n      txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n      txn.objForEncoding = txnForEnc;\n      return txn;\n    }\n\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version multisig version\n   * @param threshold multisig threshold\n   * @param pks multisig public key list, order is important.\n   * @param sk an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n\n\n  partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk) {\n    // verify one more time that the from field is correct\n    if (!this.hasOwnProperty(\"objForEncoding\")) {\n      let expectedFromRaw = address.fromMultisigPreImg({\n        version,\n        threshold,\n        pks\n      });\n\n      if (address.encodeAddress(this.from.publicKey) !== address.encodeAddress(expectedFromRaw)) {\n        throw ERROR_MULTISIG_BAD_FROM_FIELD;\n      }\n    } // get signature verifier\n\n\n    let myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransaction(this.get_obj_for_encoding(), {\n      \"rawSig\": this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n\n}\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\n\n\nfunction createMultisigTransaction(txnForEncoding, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  let keyExist = false; // construct the appendable multisigned transaction format\n\n  let subsigs = pks.map(pk => {\n    if (nacl.bytesEqual(pk, myPk)) {\n      keyExist = true;\n      return {\n        \"pk\": Buffer.from(pk),\n        \"s\": rawSig\n      };\n    }\n\n    return {\n      \"pk\": Buffer.from(pk)\n    };\n  });\n\n  if (keyExist === false) {\n    throw ERROR_MULTISIG_KEY_NOT_EXIST;\n  }\n\n  let msig = {\n    \"v\": version,\n    \"thr\": threshold,\n    \"subsig\": subsigs\n  };\n  let sTxn = {\n    \"msig\": msig,\n    \"txn\": txnForEncoding\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw ERROR_MULTISIG_MERGE_LESSTHANTWO;\n  }\n\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n  const refTxIDStr = refSigAlgoTx.txID().toString();\n  const from = address.encodeAddress(refSigTx.txn.snd);\n  let newSubsigs = refSigTx.msig.subsig;\n\n  for (let i = 0; i < multisigTxnBlobs.length; i++) {\n    let unisig = encoding.decode(multisigTxnBlobs[i]);\n    let unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n\n    if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n      throw ERROR_MULTISIG_MERGE_MISMATCH;\n    } // check multisig has same preimage as reference\n\n\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    }\n\n    let preimg = {\n      \"version\": unisig.msig.v,\n      \"threshold\": unisig.msig.thr,\n      \"pks\": unisig.msig.subsig.map(subsig => {\n        return subsig.pk;\n      })\n    };\n\n    if (from !== address.encodeAddress(address.fromMultisigPreImg(preimg))) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    } // now, we can merge\n\n\n    newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {\n      let current = newSubsigs[index];\n\n      if (current.s) {\n        if (uniSubsig.s && Buffer.compare(uniSubsig.s, current.s) !== 0) {\n          // mismatch\n          throw ERROR_MULTISIG_MERGE_SIG_MISMATCH;\n        }\n\n        return {\n          \"pk\": current.pk,\n          \"s\": current.s\n        };\n      } else if (uniSubsig.s) {\n        return {\n          \"pk\": current.pk,\n          \"s\": uniSubsig.s\n        };\n      }\n\n      return current;\n    });\n  }\n\n  let msig = {\n    \"v\": refSigTx.msig.v,\n    \"thr\": refSigTx.msig.thr,\n    \"subsig\": newSubsigs\n  };\n  let sTxn = {\n    \"msig\": msig,\n    \"txn\": refSigTx.txn\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\nfunction verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  let pks = subsigs.map(subsig => subsig.pk);\n\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk;\n\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n\n  for (let subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n\n  for (let subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  MultisigTransaction,\n  mergeMultisigTransactions,\n  createMultisigTransaction,\n  verifyMultisig,\n  ERROR_MULTISIG_MERGE_LESSTHANTWO,\n  ERROR_MULTISIG_MERGE_MISMATCH,\n  ERROR_MULTISIG_MERGE_WRONG_PREIMAGE,\n  ERROR_MULTISIG_MERGE_SIG_MISMATCH\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/multisig.js"],"names":["Buffer","require","nacl","address","encoding","txnBuilder","utils","ERROR_MULTISIG_MERGE_LESSTHANTWO","Error","ERROR_MULTISIG_MERGE_MISMATCH","ERROR_MULTISIG_MERGE_WRONG_PREIMAGE","ERROR_MULTISIG_MERGE_SIG_MISMATCH","ERROR_MULTISIG_BAD_FROM_FIELD","ERROR_MULTISIG_KEY_NOT_EXIST","MultisigTransaction","Transaction","get_obj_for_encoding","hasOwnProperty","objForEncoding","from_obj_for_encoding","txnForEnc","type","txn","Object","create","prototype","name","tag","from","partialSignTxn","version","threshold","pks","sk","expectedFromRaw","fromMultisigPreImg","encodeAddress","publicKey","myPk","keyPairFromSecretKey","createMultisigTransaction","rawSignTxn","txnForEncoding","rawSig","keyExist","subsigs","map","pk","bytesEqual","msig","sTxn","Uint8Array","encode","mergeMultisigTransactions","multisigTxnBlobs","length","refSigTx","decode","refSigAlgoTx","refTxIDStr","txID","toString","snd","newSubsigs","subsig","i","unisig","unisigAlgoTxn","preimg","v","thr","uniSubsig","index","current","s","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","undefined","verifiedCounter","verify","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst nacl = require('./nacl/naclWrappers');\nconst address = require('./encoding/address');\nconst encoding = require('./encoding/encoding');\nconst txnBuilder = require('./transaction');\nconst utils = require('./utils/utils');\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\nconst ERROR_MULTISIG_MERGE_LESSTHANTWO = new Error(\"Not enough multisig transactions to merge. Need at least two\");\nconst ERROR_MULTISIG_MERGE_MISMATCH = new Error(\"Cannot merge txs. txIDs differ\");\nconst ERROR_MULTISIG_MERGE_WRONG_PREIMAGE = new Error(\"Cannot merge txs. Multisig preimages differ\");\nconst ERROR_MULTISIG_MERGE_SIG_MISMATCH = new Error(\"Cannot merge txs. subsigs are mismatched.\");\nconst ERROR_MULTISIG_BAD_FROM_FIELD = new Error(\"The transaction from field and multisig preimage do not match.\");\nconst ERROR_MULTISIG_KEY_NOT_EXIST = new Error(\"Key does not exist\");\n\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nclass MultisigTransaction extends txnBuilder.Transaction {\n    get_obj_for_encoding() {\n        if (this.hasOwnProperty(\"objForEncoding\")) {\n            // if set, use the value for encoding. This allows us to sign existing non-payment type transactions.\n            return this.objForEncoding;\n        }\n        return super.get_obj_for_encoding();\n    }\n\n    static from_obj_for_encoding(txnForEnc) {\n        if (txnForEnc.type !== \"pay\") {\n            // we don't support decoding this txn yet - but we can keep signing it since we have the\n            // encoded format. We trust that the caller knows what they are trying to sign.\n            let txn = Object.create(this.prototype);\n            txn.name = \"Transaction\";\n            txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n            txn.objForEncoding = txnForEnc;\n            return txn;\n        }\n        return super.from_obj_for_encoding(txnForEnc);\n    }\n\n    /**\n     * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n     * encoded with msgpack as a typed array.\n     * @param version multisig version\n     * @param threshold multisig threshold\n     * @param pks multisig public key list, order is important.\n     * @param sk an Algorand secret key to sign with.\n     * @returns an encoded, partially signed multisig transaction.\n     */\n    partialSignTxn({version, threshold, pks}, sk) {\n        // verify one more time that the from field is correct\n        if (!this.hasOwnProperty(\"objForEncoding\")) {\n            let expectedFromRaw = address.fromMultisigPreImg({version, threshold, pks});\n            if (address.encodeAddress(this.from.publicKey) !== address.encodeAddress(expectedFromRaw)) {\n                throw ERROR_MULTISIG_BAD_FROM_FIELD;\n            }\n        }\n        // get signature verifier\n        let myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n        return createMultisigTransaction(\n            this.get_obj_for_encoding(),\n            {\"rawSig\": this.rawSignTxn(sk), myPk},\n            {version, threshold, pks},\n        );\n    }\n}\n\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransaction(txnForEncoding, {rawSig, myPk}, {version, threshold, pks}) {\n    let keyExist = false;\n    // construct the appendable multisigned transaction format\n    let subsigs = pks.map(pk => {\n        if (nacl.bytesEqual(pk, myPk)) {\n            keyExist = true;\n            return {\n                \"pk\": Buffer.from(pk),\n                \"s\" : rawSig,\n            };\n        }\n        return {\"pk\": Buffer.from(pk)};\n    });\n    if (keyExist === false) {\n        throw ERROR_MULTISIG_KEY_NOT_EXIST;\n    }\n    let msig = {\n        \"v\": version,\n        \"thr\": threshold,\n        \"subsig\": subsigs,\n    };\n    let sTxn = {\n        \"msig\": msig,\n        \"txn\": txnForEncoding,\n    };\n    return new Uint8Array(encoding.encode(sTxn));\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n    if (multisigTxnBlobs.length < 2) {\n        throw ERROR_MULTISIG_MERGE_LESSTHANTWO;\n    }\n    const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n    const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n    const refTxIDStr = refSigAlgoTx.txID().toString();\n    const from = address.encodeAddress(refSigTx.txn.snd);\n\n    let newSubsigs = refSigTx.msig.subsig;\n    for (let i = 0; i < multisigTxnBlobs.length; i++) {\n        let unisig = encoding.decode(multisigTxnBlobs[i]);\n        let unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n        if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n            throw ERROR_MULTISIG_MERGE_MISMATCH;\n        }\n        // check multisig has same preimage as reference\n        if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n            throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n        }\n        let preimg = {\n            \"version\": unisig.msig.v,\n            \"threshold\": unisig.msig.thr,\n            \"pks\": unisig.msig.subsig.map(subsig => {\n                return subsig.pk;\n            }),\n        };\n        if (from !== address.encodeAddress(address.fromMultisigPreImg(preimg))) {\n            throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n        }\n        // now, we can merge\n        newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {\n            let current = newSubsigs[index];\n            if (current.s) {\n                if (uniSubsig.s && Buffer.compare(uniSubsig.s, current.s) !== 0) {\n                    // mismatch\n                    throw ERROR_MULTISIG_MERGE_SIG_MISMATCH;\n                }\n                return {\n                    \"pk\": current.pk,\n                    \"s\": current.s,\n                }\n            } else if (uniSubsig.s) {\n                return {\n                    \"pk\": current.pk,\n                    \"s\": uniSubsig.s,\n                }\n            }\n            return current;\n        });\n    }\n    let msig = {\n        \"v\": refSigTx.msig.v,\n        \"thr\": refSigTx.msig.thr,\n        \"subsig\": newSubsigs,\n    };\n    let sTxn = {\n        \"msig\": msig,\n        \"txn\": refSigTx.txn,\n    };\n    return new Uint8Array(encoding.encode(sTxn));\n}\n\nfunction verifyMultisig(toBeVerified, msig, publicKey) {\n    const version = msig.v;\n    const threshold = msig.thr;\n    const subsigs = msig.subsig;\n\n    let pks = subsigs.map(\n        (subsig) => subsig.pk\n    );\n    if (msig.subsig.length < threshold) {\n        return false;\n    }\n\n    let pk;\n    try {\n        pk = address.fromMultisigPreImg({version, threshold, pks});\n    } catch (e) {\n        return false;\n    }\n\n    if (!utils.arrayEqual(pk, publicKey)) {\n        return false;\n    }\n\n    let counter = 0;\n    for (let subsig of subsigs) {\n        if (subsig.s !== undefined) {\n            counter += 1;\n        }\n    }\n    if (counter < threshold) {\n        return false;\n    }\n\n    let verifiedCounter = 0;\n    for (let subsig of subsigs) {\n        if (subsig.s !== undefined) {\n            if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n                verifiedCounter += 1;\n            }\n        }\n    }\n\n    if (verifiedCounter < threshold) {\n        return false;\n    }\n\n    return true;\n}\n\nmodule.exports = {\n    MultisigTransaction,\n    mergeMultisigTransactions,\n    createMultisigTransaction,\n    verifyMultisig,\n    ERROR_MULTISIG_MERGE_LESSTHANTWO,\n    ERROR_MULTISIG_MERGE_MISMATCH,\n    ERROR_MULTISIG_MERGE_WRONG_PREIMAGE,\n    ERROR_MULTISIG_MERGE_SIG_MISMATCH,\n};\n"]},"metadata":{},"sourceType":"script"}