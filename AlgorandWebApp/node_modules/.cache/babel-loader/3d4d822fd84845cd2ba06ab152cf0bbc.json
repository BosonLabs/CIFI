{"ast":null,"code":"/**\n Utilities for working with program bytes.\n */\nconst langspec = require(\"./langspec.json\");\n\nlet opcodes;\nconst maxCost = 20000;\nconst maxLength = 1000;\n/**\n * checkProgram validates program for length and running cost\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {boolean} true if success\n */\n\nfunction checkProgram(program, args) {\n  [_, _, success] = readProgram(program, args);\n  return success;\n}\n/** readProgram validates program for length and running cost,\n * and additionally provides the found int variables and byte blocks\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {[Uint8Array, [Uint8Array], boolean]}\n */\n\n\nfunction readProgram(program, args) {\n  const intcblockOpcode = 32;\n  const bytecblockOpcode = 38;\n\n  if (!program) {\n    throw new Error(\"empty program\");\n  }\n\n  if (args == undefined) {\n    args = [];\n  }\n\n  if (!Array.isArray(args)) {\n    throw new Error(\"invalid arguments\");\n  }\n\n  let [version, vlen] = parseUvarint(program);\n\n  if (vlen <= 0) {\n    throw new Error(\"version parsing error\");\n  }\n\n  if (version > langspec.EvalMaxVersion) {\n    throw new Error(\"unsupported version\");\n  }\n\n  let cost = 0;\n  let length = program.length;\n\n  for (let arg of args) {\n    length += arg.length;\n  }\n\n  if (length > maxLength) {\n    throw new Error(\"program too long\");\n  }\n\n  if (!opcodes) {\n    opcodes = {};\n\n    for (let op of langspec.Ops) {\n      opcodes[op.Opcode] = op;\n    }\n  }\n\n  let pc = vlen;\n  let ints = [];\n  let byteArrays = [];\n\n  while (pc < program.length) {\n    let op = opcodes[program[pc]];\n\n    if (op === undefined) {\n      throw new Error(\"invalid instruction\");\n    }\n\n    cost += op.Cost;\n    let size = op.Size;\n\n    if (size == 0) {\n      switch (op.Opcode) {\n        case intcblockOpcode:\n          {\n            [size, foundInts] = readIntConstBlock(program, pc);\n            ints = ints.concat(foundInts);\n            break;\n          }\n\n        case bytecblockOpcode:\n          {\n            [size, foundByteArrays] = readByteConstBlock(program, pc);\n            byteArrays = byteArrays.concat(foundByteArrays);\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"invalid instruction\");\n          }\n      }\n    }\n\n    pc += size;\n  }\n\n  if (cost > maxCost) {\n    throw new Error(\"program too costly to run\");\n  }\n\n  return [ints, byteArrays, true];\n}\n\nfunction checkIntConstBlock(program, pc) {\n  let [size, unused] = readIntConstBlock(program, pc);\n  return size;\n}\n\nfunction readIntConstBlock(program, pc) {\n  let size = 1;\n  let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode int const block size at pc=${pc + size}`);\n  }\n\n  let ints = [];\n  size += bytesUsed;\n\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error(\"intcblock ran past end of program\");\n    }\n\n    let [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n    if (bytesUsed <= 0) {\n      throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);\n    }\n\n    ints.push(numberFound);\n    size += bytesUsed;\n  }\n\n  return [size, ints];\n}\n\nfunction checkByteConstBlock(program, pc) {\n  let [size, unused] = readByteConstBlock(program, pc);\n  return size;\n}\n\nfunction readByteConstBlock(program, pc) {\n  let size = 1;\n  let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n  if (bytesUsed <= 0) {\n    throw new Error(`could not decode []byte const block size at pc=${pc + size}`);\n  }\n\n  let byteArrays = [];\n  size += bytesUsed;\n\n  for (let i = 0; i < numInts; i++) {\n    if (pc + size >= program.length) {\n      throw new Error(\"bytecblock ran past end of program\");\n    }\n\n    let [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n\n    if (bytesUsed <= 0) {\n      throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);\n    }\n\n    size += bytesUsed;\n\n    if (pc + size >= program.length) {\n      throw new Error(\"bytecblock ran past end of program\");\n    }\n\n    let byteArray = program.slice(pc + size, pc + size + itemLen);\n    byteArrays.push(byteArray);\n    size += itemLen;\n  }\n\n  return [size, byteArrays];\n}\n\nfunction parseUvarint(array) {\n  let x = 0;\n  let s = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    b = array[i];\n\n    if (b < 0x80) {\n      if (i > 9 || i == 9 && b > 1) {\n        return [0, -(i + 1)];\n      }\n\n      return [x | b << s, i + 1];\n    }\n\n    x += (b & 0x7f) << s;\n    s += 7;\n  }\n\n  return [0, 0];\n}\n\nmodule.exports = {\n  checkProgram,\n  readProgram,\n  parseUvarint,\n  checkIntConstBlock,\n  checkByteConstBlock,\n  langspecEvalMaxVersion: langspec.EvalMaxVersion,\n  langspecLogicSigVersion: langspec.LogicSigVersion\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/logic/logic.js"],"names":["langspec","require","opcodes","maxCost","maxLength","checkProgram","program","args","_","success","readProgram","intcblockOpcode","bytecblockOpcode","Error","undefined","Array","isArray","version","vlen","parseUvarint","EvalMaxVersion","cost","length","arg","op","Ops","Opcode","pc","ints","byteArrays","Cost","size","Size","foundInts","readIntConstBlock","concat","foundByteArrays","readByteConstBlock","checkIntConstBlock","unused","numInts","bytesUsed","slice","i","numberFound","push","checkByteConstBlock","itemLen","byteArray","array","x","s","b","module","exports","langspecEvalMaxVersion","langspecLogicSigVersion","LogicSigVersion"],"mappings":"AAAA;AACA;AACA;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAD,CAAxB;;AAEA,IAAIC,OAAJ;AAEA,MAAMC,OAAO,GAAG,KAAhB;AACA,MAAMC,SAAS,GAAG,IAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,IAA/B,EAAqC;AACjC,GAACC,CAAD,EAAIA,CAAJ,EAAOC,OAAP,IAAkBC,WAAW,CAACJ,OAAD,EAAUC,IAAV,CAA7B;AACA,SAAOE,OAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,CAAqBJ,OAArB,EAA8BC,IAA9B,EAAoC;AAChC,QAAMI,eAAe,GAAG,EAAxB;AACA,QAAMC,gBAAgB,GAAG,EAAzB;;AACA,MAAI,CAACN,OAAL,EAAc;AACV,UAAM,IAAIO,KAAJ,CAAU,eAAV,CAAN;AACH;;AAED,MAAIN,IAAI,IAAIO,SAAZ,EAAuB;AACnBP,IAAAA,IAAI,GAAG,EAAP;AACH;;AACD,MAAI,CAACQ,KAAK,CAACC,OAAN,CAAcT,IAAd,CAAL,EAA0B;AACtB,UAAM,IAAIM,KAAJ,CAAU,mBAAV,CAAN;AACH;;AAED,MAAI,CAACI,OAAD,EAAUC,IAAV,IAAkBC,YAAY,CAACb,OAAD,CAAlC;;AACA,MAAIY,IAAI,IAAI,CAAZ,EAAe;AACX,UAAM,IAAIL,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACD,MAAII,OAAO,GAAGjB,QAAQ,CAACoB,cAAvB,EAAuC;AACnC,UAAM,IAAIP,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAED,MAAIQ,IAAI,GAAG,CAAX;AACA,MAAIC,MAAM,GAAEhB,OAAO,CAACgB,MAApB;;AACA,OAAK,IAAIC,GAAT,IAAgBhB,IAAhB,EAAsB;AAClBe,IAAAA,MAAM,IAAIC,GAAG,CAACD,MAAd;AACH;;AACD,MAAIA,MAAM,GAAGlB,SAAb,EAAwB;AACpB,UAAM,IAAIS,KAAJ,CAAU,kBAAV,CAAN;AACH;;AAED,MAAI,CAACX,OAAL,EAAc;AACVA,IAAAA,OAAO,GAAG,EAAV;;AACA,SAAK,IAAIsB,EAAT,IAAexB,QAAQ,CAACyB,GAAxB,EAA6B;AACzBvB,MAAAA,OAAO,CAACsB,EAAE,CAACE,MAAJ,CAAP,GAAqBF,EAArB;AACH;AACJ;;AAED,MAAIG,EAAE,GAAGT,IAAT;AACA,MAAIU,IAAI,GAAG,EAAX;AACA,MAAIC,UAAU,GAAG,EAAjB;;AACA,SAAOF,EAAE,GAAGrB,OAAO,CAACgB,MAApB,EAA4B;AACxB,QAAIE,EAAE,GAAGtB,OAAO,CAACI,OAAO,CAACqB,EAAD,CAAR,CAAhB;;AACA,QAAIH,EAAE,KAAKV,SAAX,EAAsB;AAClB,YAAM,IAAID,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAEDQ,IAAAA,IAAI,IAAIG,EAAE,CAACM,IAAX;AACA,QAAIC,IAAI,GAAGP,EAAE,CAACQ,IAAd;;AACA,QAAID,IAAI,IAAI,CAAZ,EAAe;AACX,cAAQP,EAAE,CAACE,MAAX;AACI,aAAKf,eAAL;AAAsB;AAClB,aAACoB,IAAD,EAAOE,SAAP,IAAoBC,iBAAiB,CAAC5B,OAAD,EAAUqB,EAAV,CAArC;AACAC,YAAAA,IAAI,GAAGA,IAAI,CAACO,MAAL,CAAYF,SAAZ,CAAP;AACA;AACH;;AACD,aAAKrB,gBAAL;AAAuB;AACnB,aAACmB,IAAD,EAAOK,eAAP,IAA0BC,kBAAkB,CAAC/B,OAAD,EAAUqB,EAAV,CAA5C;AACAE,YAAAA,UAAU,GAAGA,UAAU,CAACM,MAAX,CAAkBC,eAAlB,CAAb;AACA;AACH;;AACD;AAAS;AACL,kBAAM,IAAIvB,KAAJ,CAAU,qBAAV,CAAN;AACH;AAbL;AAeH;;AACDc,IAAAA,EAAE,IAAII,IAAN;AACH;;AAED,MAAIV,IAAI,GAAGlB,OAAX,EAAoB;AAChB,UAAM,IAAIU,KAAJ,CAAU,2BAAV,CAAN;AACH;;AAED,SAAO,CAACe,IAAD,EAAOC,UAAP,EAAmB,IAAnB,CAAP;AACH;;AAED,SAASS,kBAAT,CAA4BhC,OAA5B,EAAqCqB,EAArC,EAAyC;AACrC,MAAI,CAACI,IAAD,EAAOQ,MAAP,IAAiBL,iBAAiB,CAAC5B,OAAD,EAAUqB,EAAV,CAAtC;AACA,SAAOI,IAAP;AACH;;AAED,SAASG,iBAAT,CAA2B5B,OAA3B,EAAoCqB,EAApC,EAAwC;AACpC,MAAII,IAAI,GAAG,CAAX;AACA,MAAI,CAACS,OAAD,EAAUC,SAAV,IAAuBtB,YAAY,CAACb,OAAO,CAACoC,KAAR,CAAcf,EAAE,GAAGI,IAAnB,CAAD,CAAvC;;AACA,MAAIU,SAAS,IAAI,CAAjB,EAAoB;AAChB,UAAM,IAAI5B,KAAJ,CAAW,+CAA8Cc,EAAE,GAAGI,IAAK,EAAnE,CAAN;AACH;;AACD,MAAIH,IAAI,GAAG,EAAX;AACAG,EAAAA,IAAI,IAAIU,SAAR;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAApB,EAA6BG,CAAC,EAA9B,EAAkC;AAC9B,QAAIhB,EAAE,GAAGI,IAAL,IAAazB,OAAO,CAACgB,MAAzB,EAAiC;AAC7B,YAAM,IAAIT,KAAJ,CAAU,mCAAV,CAAN;AACH;;AACD,QAAI,CAAC+B,WAAD,EAAcH,SAAd,IAA2BtB,YAAY,CAACb,OAAO,CAACoC,KAAR,CAAcf,EAAE,GAAGI,IAAnB,CAAD,CAA3C;;AACA,QAAIU,SAAS,IAAI,CAAjB,EAAoB;AAChB,YAAM,IAAI5B,KAAJ,CAAW,8BAA6B8B,CAAE,sBAAqBhB,EAAE,GAAGI,IAAK,EAAzE,CAAN;AACH;;AACDH,IAAAA,IAAI,CAACiB,IAAL,CAAUD,WAAV;AACAb,IAAAA,IAAI,IAAIU,SAAR;AACH;;AACD,SAAO,CAACV,IAAD,EAAOH,IAAP,CAAP;AACH;;AAED,SAASkB,mBAAT,CAA6BxC,OAA7B,EAAsCqB,EAAtC,EAA0C;AACtC,MAAI,CAACI,IAAD,EAAOQ,MAAP,IAAiBF,kBAAkB,CAAC/B,OAAD,EAAUqB,EAAV,CAAvC;AACA,SAAOI,IAAP;AACH;;AAED,SAASM,kBAAT,CAA4B/B,OAA5B,EAAqCqB,EAArC,EAAyC;AACrC,MAAII,IAAI,GAAG,CAAX;AACA,MAAI,CAACS,OAAD,EAAUC,SAAV,IAAuBtB,YAAY,CAACb,OAAO,CAACoC,KAAR,CAAcf,EAAE,GAAGI,IAAnB,CAAD,CAAvC;;AACA,MAAIU,SAAS,IAAI,CAAjB,EAAoB;AAChB,UAAM,IAAI5B,KAAJ,CAAW,kDAAiDc,EAAE,GAAGI,IAAK,EAAtE,CAAN;AACH;;AACD,MAAIF,UAAU,GAAG,EAAjB;AACAE,EAAAA,IAAI,IAAIU,SAAR;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAApB,EAA6BG,CAAC,EAA9B,EAAkC;AAC9B,QAAIhB,EAAE,GAAGI,IAAL,IAAazB,OAAO,CAACgB,MAAzB,EAAiC;AAC7B,YAAM,IAAIT,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,QAAI,CAACkC,OAAD,EAAUN,SAAV,IAAuBtB,YAAY,CAACb,OAAO,CAACoC,KAAR,CAAcf,EAAE,GAAGI,IAAnB,CAAD,CAAvC;;AACA,QAAIU,SAAS,IAAI,CAAjB,EAAoB;AAChB,YAAM,IAAI5B,KAAJ,CAAW,kCAAiC8B,CAAE,sBAAqBhB,EAAE,GAAGI,IAAK,EAA7E,CAAN;AACH;;AACDA,IAAAA,IAAI,IAAIU,SAAR;;AACA,QAAId,EAAE,GAAGI,IAAL,IAAazB,OAAO,CAACgB,MAAzB,EAAiC;AAC7B,YAAM,IAAIT,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,QAAImC,SAAS,GAAG1C,OAAO,CAACoC,KAAR,CAAcf,EAAE,GAACI,IAAjB,EAAuBJ,EAAE,GAACI,IAAH,GAAQgB,OAA/B,CAAhB;AACAlB,IAAAA,UAAU,CAACgB,IAAX,CAAgBG,SAAhB;AACAjB,IAAAA,IAAI,IAAIgB,OAAR;AACH;;AACD,SAAO,CAAChB,IAAD,EAAOF,UAAP,CAAP;AACH;;AAED,SAASV,YAAT,CAAsB8B,KAAtB,EAA6B;AACzB,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;;AACA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,KAAK,CAAC3B,MAA1B,EAAkCqB,CAAC,EAAnC,EAAuC;AACnCS,IAAAA,CAAC,GAAGH,KAAK,CAACN,CAAD,CAAT;;AACA,QAAIS,CAAC,GAAG,IAAR,EAAc;AACV,UAAIT,CAAC,GAAG,CAAJ,IAASA,CAAC,IAAI,CAAL,IAAUS,CAAC,GAAG,CAA3B,EAA8B;AAC1B,eAAO,CAAC,CAAD,EAAI,EAAET,CAAC,GAAG,CAAN,CAAJ,CAAP;AACH;;AACD,aAAO,CAACO,CAAC,GAAGE,CAAC,IAAID,CAAV,EAAaR,CAAC,GAAG,CAAjB,CAAP;AACH;;AACDO,IAAAA,CAAC,IAAI,CAACE,CAAC,GAAG,IAAL,KAAcD,CAAnB;AACAA,IAAAA,CAAC,IAAI,CAAL;AACH;;AACD,SAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACH;;AAEDE,MAAM,CAACC,OAAP,GAAiB;AACbjD,EAAAA,YADa;AAEbK,EAAAA,WAFa;AAGbS,EAAAA,YAHa;AAIbmB,EAAAA,kBAJa;AAKbQ,EAAAA,mBALa;AAMbS,EAAAA,sBAAsB,EAAEvD,QAAQ,CAACoB,cANpB;AAOboC,EAAAA,uBAAuB,EAAExD,QAAQ,CAACyD;AAPrB,CAAjB","sourcesContent":["/**\n Utilities for working with program bytes.\n */\n\nconst langspec = require(\"./langspec.json\")\n\nlet opcodes;\n\nconst maxCost = 20000;\nconst maxLength = 1000;\n\n/**\n * checkProgram validates program for length and running cost\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {boolean} true if success\n */\nfunction checkProgram(program, args) {\n    [_, _, success] = readProgram(program, args);\n    return success\n}\n\n/** readProgram validates program for length and running cost,\n * and additionally provides the found int variables and byte blocks\n * @param {Uint8Array} program Program to check\n * @param {[Uint8Array]} args Program arguments as array of Uint8Array arrays\n * @throws {Error}\n * @returns {[Uint8Array, [Uint8Array], boolean]}\n */\nfunction readProgram(program, args) {\n    const intcblockOpcode = 32;\n    const bytecblockOpcode = 38;\n    if (!program) {\n        throw new Error(\"empty program\");\n    }\n\n    if (args == undefined) {\n        args = []\n    }\n    if (!Array.isArray(args)) {\n        throw new Error(\"invalid arguments\");\n    }\n\n    let [version, vlen] = parseUvarint(program);\n    if (vlen <= 0) {\n        throw new Error(\"version parsing error\");\n    }\n    if (version > langspec.EvalMaxVersion) {\n        throw new Error(\"unsupported version\");\n    }\n\n    let cost = 0;\n    let length =program.length;\n    for (let arg of args) {\n        length += arg.length;\n    }\n    if (length > maxLength) {\n        throw new Error(\"program too long\");\n    }\n\n    if (!opcodes) {\n        opcodes = {}\n        for (let op of langspec.Ops) {\n            opcodes[op.Opcode] = op;\n        }\n    }\n\n    let pc = vlen;\n    let ints = [];\n    let byteArrays = [];\n    while (pc < program.length) {\n        let op = opcodes[program[pc]];\n        if (op === undefined) {\n            throw new Error(\"invalid instruction\");\n        }\n\n        cost += op.Cost;\n        let size = op.Size;\n        if (size == 0) {\n            switch (op.Opcode) {\n                case intcblockOpcode: {\n                    [size, foundInts] = readIntConstBlock(program, pc);\n                    ints = ints.concat(foundInts);\n                    break;\n                }\n                case bytecblockOpcode: {\n                    [size, foundByteArrays] = readByteConstBlock(program, pc);\n                    byteArrays = byteArrays.concat(foundByteArrays);\n                    break;\n                }\n                default: {\n                    throw new Error(\"invalid instruction\");\n                }\n            }\n        }\n        pc += size;\n    }\n\n    if (cost > maxCost) {\n        throw new Error(\"program too costly to run\");\n    }\n\n    return [ints, byteArrays, true];\n}\n\nfunction checkIntConstBlock(program, pc) {\n    let [size, unused] = readIntConstBlock(program, pc);\n    return size;\n}\n\nfunction readIntConstBlock(program, pc) {\n    let size = 1;\n    let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));\n    if (bytesUsed <= 0) {\n        throw new Error(`could not decode int const block size at pc=${pc + size}`);\n    }\n    let ints = [];\n    size += bytesUsed;\n    for (let i = 0; i < numInts; i++) {\n        if (pc + size >= program.length) {\n            throw new Error(\"intcblock ran past end of program\");\n        }\n        let [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));\n        if (bytesUsed <= 0) {\n            throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);\n        }\n        ints.push(numberFound);\n        size += bytesUsed;\n    }\n    return [size, ints];\n}\n\nfunction checkByteConstBlock(program, pc) {\n    let [size, unused] = readByteConstBlock(program, pc);\n    return size;\n}\n\nfunction readByteConstBlock(program, pc) {\n    let size = 1;\n    let [numInts, bytesUsed] = parseUvarint(program.slice(pc + size));\n    if (bytesUsed <= 0) {\n        throw new Error(`could not decode []byte const block size at pc=${pc + size}`);\n    }\n    let byteArrays = [];\n    size += bytesUsed;\n    for (let i = 0; i < numInts; i++) {\n        if (pc + size >= program.length) {\n            throw new Error(\"bytecblock ran past end of program\");\n        }\n        let [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));\n        if (bytesUsed <= 0) {\n            throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);\n        }\n        size += bytesUsed;\n        if (pc + size >= program.length) {\n            throw new Error(\"bytecblock ran past end of program\");\n        }\n        let byteArray = program.slice(pc+size, pc+size+itemLen);\n        byteArrays.push(byteArray);\n        size += itemLen;\n    }\n    return [size, byteArrays];\n}\n\nfunction parseUvarint(array) {\n    let x = 0;\n    let s = 0;\n    for (let i = 0; i < array.length; i++) {\n        b = array[i];\n        if (b < 0x80) {\n            if (i > 9 || i == 9 && b > 1) {\n                return [0, -(i + 1)];\n            }\n            return [x | b << s, i + 1];\n        }\n        x += (b & 0x7f) << s;\n        s += 7;\n    }\n    return [0, 0];\n}\n\nmodule.exports = {\n    checkProgram,\n    readProgram,\n    parseUvarint,\n    checkIntConstBlock,\n    checkByteConstBlock,\n    langspecEvalMaxVersion: langspec.EvalMaxVersion,\n    langspecLogicSigVersion: langspec.LogicSigVersion,\n};\n"]},"metadata":{},"sourceType":"script"}