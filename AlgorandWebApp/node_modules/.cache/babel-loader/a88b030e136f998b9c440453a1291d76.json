{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\n\nconst client = require('./client');\n\nfunction Algod(token = '', baseServer = \"http://r2.algorand.network\", port = 4180, headers = {}) {\n  // workaround to allow backwards compatibility for multiple headers\n  let tokenHeader = token;\n\n  if (typeof tokenHeader == 'string') {\n    tokenHeader = {\n      \"X-Algo-API-Token\": tokenHeader\n    };\n  } // Get client\n\n\n  let c = new client.HTTPClient(tokenHeader, baseServer, port, headers);\n  /**\n   * Takes an object and convert its note field to Buffer, if exist.\n   * @param o\n   * @returns {*}\n   */\n\n  function noteb64ToNote(o) {\n    if (!(o.noteb64 === undefined || o.noteb64 === null)) {\n      o.note = Buffer.from(o.noteb64, \"base64\");\n    }\n\n    return o;\n  }\n  /**\n   * Sets the default header (if not previously set) for sending a raw\n   * transaction.\n   * @param headers\n   * @returns {*}\n   */\n\n\n  function setSendTransactionHeaders(headers) {\n    let hdrs = headers;\n\n    if (Object.keys(hdrs).every(key => key.toLowerCase() !== 'content-type')) {\n      hdrs = { ...headers\n      };\n      hdrs['Content-Type'] = 'application/x-binary';\n    }\n\n    return hdrs;\n  }\n  /**\n   * status retrieves the StatusResponse from the running node\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.status = async function (headers = {}) {\n    let res = await c.get(\"/v1/status\", {}, headers);\n    return res.body;\n  };\n  /**\n   * healthCheck returns an empty object iff the node is running\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.healthCheck = async function (headers = {}) {\n    let res = await c.get(\"/health\", {}, headers);\n\n    if (!res.ok) {\n      throw new Error(\"Health response: \" + res.status);\n    }\n\n    return {};\n  };\n  /**\n   * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n   * This call blocks\n   * @param roundNumber\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.statusAfterBlock = async function (roundNumber, headers = {}) {\n    if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n    let res = await c.get(\"/v1/status/wait-for-block-after/\" + roundNumber, {}, headers);\n    return res.body;\n  };\n  /**\n   * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n   * If maxTxns = 0, fetches as many transactions as possible.\n   * @param maxTxns number\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactions = async function (maxTxns, headers = {}) {\n    if (!Number.isInteger(maxTxns)) throw Error(\"maxTxns should be an integer\");\n    let res = await c.get(\"/v1/transactions/pending\", {\n      'max': maxTxns\n    }, headers);\n\n    if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {\n      for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n        res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * versions retrieves the VersionResponse from the running node\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.versions = async function (headers = {}) {\n    let res = await c.get(\"/versions\", {}, headers);\n    return res.body;\n  };\n  /**\n   * LedgerSupply gets the supply details for the specified node's Ledger\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.ledgerSupply = async function (headers = {}) {\n    let res = await c.get(\"/v1/ledger/supply\", {}, headers);\n    return res.body;\n  };\n  /**\n   * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n   * @param addr string\n   * @param first number, optional\n   * @param last number, optional\n   * @param maxTxns number, optional\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddress = async function (addr, first = null, last = null, maxTxns = null, headers = {}) {\n    if (first !== null && !Number.isInteger(first)) {\n      throw Error(\"first round should be an integer\");\n    }\n\n    if (last !== null && !Number.isInteger(last)) {\n      throw Error(\"last round should be an integer\");\n    }\n\n    let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", {\n      'firstRound': first,\n      'lastRound': last,\n      'max': maxTxns\n    }, headers);\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range. \n   * The date is a string in the YYYY-MM-DD format.\n   * @param addr string\n   * @param fromDate string\n   * @param toDate string\n   * @param maxTxns number, optional\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddressAndDate = async function (addr, fromDate, toDate, maxTxns = null, headers = {}) {\n    let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", {\n      'fromDate': fromDate,\n      'toDate': toDate,\n      'max': maxTxns\n    }, headers);\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionById returns the a transaction information of a specific txid [txId]\n   * Note - This method is allowed only when Indexer is enabled.\n   * @param txid\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionById = async function (txid, headers = {}) {\n    let res = await c.get(\"/v1/transaction/\" + txid, {}, headers);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionInformation returns the transaction information of a specific txid and an address\n   * @param addr\n   * @param txid\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionInformation = async function (addr, txid, headers = {}) {\n    let res = await c.get(\"/v1/account/\" + addr + \"/transaction/\" + txid, {}, headers);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n   * @param txid\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactionInformation = async function (txid, headers = {}) {\n    let res = await c.get(\"/v1/transactions/pending/\" + txid, {}, headers);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * accountInformation returns the passed account's information\n   * @param addr string\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.accountInformation = async function (addr, headers = {}) {\n    let res = await c.get(\"/v1/account/\" + addr, {}, headers);\n    return res.body;\n  };\n  /**\n   * assetInformation returns the information for the asset with the passed creator and index\n   * @param index number\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.assetInformation = async function (index, headers = {}) {\n    let res = await c.get(\"/v1/asset/\" + index, {}, headers);\n    return res.body;\n  };\n  /**\n   * suggestedFee gets the recommended transaction fee from the node\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.suggestedFee = async function (headers = {}) {\n    let res = await c.get(\"/v1/transactions/fee\", {}, headers);\n    return res.body;\n  };\n  /**\n   * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n   * @param txn Uin8Array\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.sendRawTransaction = async function (txn, headers = {}) {\n    let txHeaders = setSendTransactionHeaders(headers);\n    let res = await c.post(\"/v1/transactions\", Buffer.from(txn), txHeaders);\n    return res.body;\n  };\n  /**\n   * sendRawTransactions gets a list of encoded SignedTxns and broadcasts it to the network\n   * @param txn Array of Uin8Array\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.sendRawTransactions = async function (txns, headers = {}) {\n    let txHeaders = setSendTransactionHeaders(headers);\n    const merged = Array.prototype.concat(...txns.map(arr => Array.from(arr)));\n    let res = await c.post(\"/v1/transactions\", Buffer.from(merged), txHeaders);\n    return res.body;\n  };\n  /**\n   * getTransactionParams returns to common needed parameters for a new transaction\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.getTransactionParams = async function (headers = {}) {\n    let res = await c.get(\"/v1/transactions/params\", {}, headers);\n    return res.body;\n  };\n  /**\n   * suggestParams returns to common needed parameters for a new transaction, in a format the transaction builder expects\n   * @param headers, optional\n   * @returns {Object}\n   */\n\n\n  this.suggestParams = async function (headers = {}) {\n    let result = await this.getTransactionParams(headers);\n    return {\n      \"flatFee\": false,\n      \"fee\": result.fee,\n      \"firstRound\": result.lastRound,\n      \"lastRound\": result.lastRound + 1000,\n      \"genesisID\": result.genesisID,\n      \"genesisHash\": result.genesishashb64\n    };\n  };\n  /**\n   * block gets the block info for the given round This call blocks\n   * @param roundNumber\n   * @param headers, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.block = async function (roundNumber, headers = {}) {\n    if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n    let res = await c.get(\"/v1/block/\" + roundNumber, {}, headers);\n\n    if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n      for (let i = 0; i < res.body.txns.transactions.length; i++) {\n        res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n}\n\nmodule.exports = {\n  Algod\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/client/algod.js"],"names":["Buffer","require","client","Algod","token","baseServer","port","headers","tokenHeader","c","HTTPClient","noteb64ToNote","o","noteb64","undefined","note","from","setSendTransactionHeaders","hdrs","Object","keys","every","key","toLowerCase","status","res","get","body","healthCheck","ok","Error","statusAfterBlock","roundNumber","Number","isInteger","pendingTransactions","maxTxns","statusCode","truncatedTxns","transactions","i","length","versions","ledgerSupply","transactionByAddress","addr","first","last","transactionByAddressAndDate","fromDate","toDate","transactionById","txid","transactionInformation","pendingTransactionInformation","accountInformation","assetInformation","index","suggestedFee","sendRawTransaction","txn","txHeaders","post","sendRawTransactions","txns","merged","Array","prototype","concat","map","arr","getTransactionParams","suggestParams","result","fee","lastRound","genesisID","genesishashb64","block","module","exports"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer');\nconst client = require('./client');\n\nfunction Algod(token = '', baseServer = \"http://r2.algorand.network\", port = 4180, headers = {}) {\n    // workaround to allow backwards compatibility for multiple headers\n    let tokenHeader = token;\n    if (typeof (tokenHeader) == 'string') {\n        tokenHeader = {\"X-Algo-API-Token\": tokenHeader};\n    }\n\n    // Get client\n    let c = new client.HTTPClient(tokenHeader, baseServer, port, headers);\n\n    /**\n     * Takes an object and convert its note field to Buffer, if exist.\n     * @param o\n     * @returns {*}\n     */\n    function noteb64ToNote(o) {\n        if (!(o.noteb64 === undefined || o.noteb64 === null)) {\n            o.note = Buffer.from(o.noteb64, \"base64\")\n        }\n        return o\n    }\n\n    /**\n     * Sets the default header (if not previously set) for sending a raw\n     * transaction.\n     * @param headers\n     * @returns {*}\n     */\n    function setSendTransactionHeaders(headers) {\n        let hdrs = headers;\n        if (Object.keys(hdrs).every(key=> key.toLowerCase() !== 'content-type')) {\n            hdrs = {...headers};\n            hdrs['Content-Type'] = 'application/x-binary';\n        }\n        return hdrs;\n    }\n\n    /**\n     * status retrieves the StatusResponse from the running node\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.status = async function (headers={}) {\n        let res = await c.get(\"/v1/status\", {}, headers);\n        return res.body;\n    };\n\n    /**\n     * healthCheck returns an empty object iff the node is running\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.healthCheck = async function (headers={}) {\n        let res = await c.get(\"/health\", {}, headers);\n        if (!res.ok) {\n            throw new Error(\"Health response: \" + res.status);\n        }\n        return {};\n    };\n\n    /**\n     * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n     * This call blocks\n     * @param roundNumber\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.statusAfterBlock = async function (roundNumber, headers={}) {\n        if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n        let res = await c.get(\"/v1/status/wait-for-block-after/\" + roundNumber, {}, headers);\n        return res.body;\n    };\n\n    /**\n     * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n     * If maxTxns = 0, fetches as many transactions as possible.\n     * @param maxTxns number\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.pendingTransactions = async function (maxTxns, headers={}) {\n        if (!Number.isInteger(maxTxns)) throw Error(\"maxTxns should be an integer\");\n        let res = await c.get(\"/v1/transactions/pending\", { 'max': maxTxns }, headers);\n        if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {\n            for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n                res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);\n            }\n        }\n        return res.body;\n    };\n\n    /**\n     * versions retrieves the VersionResponse from the running node\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.versions = async function (headers={}) {\n        let res = await c.get(\"/versions\", {}, headers);\n        return res.body;\n    };\n\n    /**\n     * LedgerSupply gets the supply details for the specified node's Ledger\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.ledgerSupply = async function (headers={}) {\n        let res = await c.get(\"/v1/ledger/supply\", {}, headers);\n        return res.body;\n    };\n\n    /**\n     * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n     * @param addr string\n     * @param first number, optional\n     * @param last number, optional\n     * @param maxTxns number, optional\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.transactionByAddress = async function (addr, first=null, last=null, maxTxns=null, headers={}) {\n\n        if (( first !== null ) && (!Number.isInteger(first) )){\n            throw Error(\"first round should be an integer\")\n        }\n        if (( last !== null ) && (!Number.isInteger(last) )){\n            throw Error(\"last round should be an integer\")\n        }\n        let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", { 'firstRound': first, 'lastRound': last, 'max': maxTxns }, headers);\n        if (res.statusCode === 200 && res.body.transactions !== undefined) {\n            for (let i = 0; i < res.body.transactions.length; i++) {\n                res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n            }\n        }\n        return res.body;\n    };\n\n    /**\n     * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range. \n     * The date is a string in the YYYY-MM-DD format.\n     * @param addr string\n     * @param fromDate string\n     * @param toDate string\n     * @param maxTxns number, optional\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.transactionByAddressAndDate = async function (addr, fromDate, toDate, maxTxns=null, headers={}) {\n        let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", { 'fromDate': fromDate, 'toDate': toDate, 'max': maxTxns }, headers);\n        if (res.statusCode === 200 && res.body.transactions !== undefined) {\n            for (let i = 0; i < res.body.transactions.length; i++) {\n                res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n            }\n        }\n        return res.body;\n    };\n\n    /**\n     * transactionById returns the a transaction information of a specific txid [txId]\n     * Note - This method is allowed only when Indexer is enabled.\n     * @param txid\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.transactionById = async function (txid, headers={}) {\n        let res = await c.get(\"/v1/transaction/\" + txid, {}, headers);\n        if (res.statusCode === 200) {\n            res.body = noteb64ToNote(res.body);\n        }\n        return res.body;\n    };\n\n    /**\n     * transactionInformation returns the transaction information of a specific txid and an address\n     * @param addr\n     * @param txid\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.transactionInformation = async function (addr, txid, headers={}) {\n        let res = await c.get(\"/v1/account/\" + addr + \"/transaction/\" + txid, {}, headers);\n        if (res.statusCode === 200) {\n            res.body = noteb64ToNote(res.body);\n        }\n        return res.body;\n    };\n\n    /**\n     * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n     * @param txid\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.pendingTransactionInformation = async function (txid, headers={}) {\n        let res = await c.get(\"/v1/transactions/pending/\" + txid, {}, headers);\n        if (res.statusCode === 200) {\n            res.body = noteb64ToNote(res.body);\n        }\n        return res.body;\n    };\n\n    /**\n     * accountInformation returns the passed account's information\n     * @param addr string\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.accountInformation = async function (addr, headers={}) {\n        let res = await c.get(\"/v1/account/\" + addr, {}, headers);\n        return res.body;\n    };\n\n    /**\n     * assetInformation returns the information for the asset with the passed creator and index\n     * @param index number\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.assetInformation = async function (index, headers={}) {\n        let res = await c.get(\"/v1/asset/\" + index, {}, headers);\n        return res.body;\n    };\n\n    /**\n     * suggestedFee gets the recommended transaction fee from the node\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.suggestedFee = async function (headers={}) {\n        let res = await c.get(\"/v1/transactions/fee\", {}, headers);\n        return res.body;\n    };\n\n    /**\n     * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n     * @param txn Uin8Array\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.sendRawTransaction = async function (txn, headers={}) {\n        let txHeaders = setSendTransactionHeaders(headers);\n        let res = await c.post(\"/v1/transactions\", Buffer.from(txn), txHeaders);\n        return res.body;\n    };\n\n    /**\n     * sendRawTransactions gets a list of encoded SignedTxns and broadcasts it to the network\n     * @param txn Array of Uin8Array\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.sendRawTransactions = async function (txns, headers={}) {\n        let txHeaders = setSendTransactionHeaders(headers);\n        const merged = Array.prototype.concat(...txns.map(arr => Array.from(arr)));\n        let res = await c.post(\"/v1/transactions\", Buffer.from(merged), txHeaders);\n        return res.body;\n    };\n\n    /**\n     * getTransactionParams returns to common needed parameters for a new transaction\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.getTransactionParams = async function (headers={}) {\n        let res = await c.get(\"/v1/transactions/params\", {}, headers);\n        return res.body;\n    };\n\n    /**\n     * suggestParams returns to common needed parameters for a new transaction, in a format the transaction builder expects\n     * @param headers, optional\n     * @returns {Object}\n     */\n    this.suggestParams = async function (headers={}) {\n        let result = await this.getTransactionParams(headers);\n        return {\n            \"flatFee\": false,\n            \"fee\": result.fee,\n            \"firstRound\": result.lastRound,\n            \"lastRound\": result.lastRound + 1000,\n            \"genesisID\": result.genesisID,\n            \"genesisHash\": result.genesishashb64,\n        };\n    };\n\n    /**\n     * block gets the block info for the given round This call blocks\n     * @param roundNumber\n     * @param headers, optional\n     * @returns {Promise<*>}\n     */\n    this.block = async function (roundNumber, headers={}) {\n        if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n        let res = await c.get(\"/v1/block/\" + roundNumber, {}, headers);\n        if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n            for (let i = 0; i < res.body.txns.transactions.length; i++) {\n                res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);\n            }\n        }\n        return res.body;\n    };\n\n}\n\n\nmodule.exports = { Algod };\n"]},"metadata":{},"sourceType":"script"}