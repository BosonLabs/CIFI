{"ast":null,"code":"const english = require(\"./wordlists/english\");\n\nconst nacl = require(\"../nacl/naclWrappers\");\n\nconst address = require(\"../encoding/address\");\n\nconst ERROR_FAIL_TO_DECODE_MNEMONIC = Error('failed to decode mnemonic');\nconst ERROR_NOT_IN_WORDS_LIST = Error('the mnemonic contains a word that is not in the wordlist');\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed 32 bytes long seed\n * @returns {string} 25 words mnemonic\n */\n\nfunction mnemonicFromSeed(seed) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(\"Seed length must be \" + nacl.SEED_BTYES_LENGTH);\n  }\n\n  const uint11Array = toUint11Array(seed);\n  const words = applyWords(uint11Array);\n  const checksumWord = computeChecksum(seed);\n  return words.join(' ') + ' ' + checksumWord;\n}\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic 25 words mnemonic\n * @returns {Uint8Array} 32 bytes long seed\n */\n\n\nfunction seedFromMnemonic(mnemonic) {\n  const words = mnemonic.split(' ');\n  const key = words.slice(0, 24); //Check that all words are in list\n\n  for (let w of key) {\n    if (english.indexOf(w) === -1) throw ERROR_NOT_IN_WORDS_LIST;\n  }\n\n  const checksum = words[words.length - 1];\n  const uint11Array = key.map(word => english.indexOf(word)); // Convert the key to uint8Array\n\n  let uint8Array = toUint8Array(uint11Array); // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n  // check that we have 33 bytes long array as expected\n\n  if (uint8Array.length !== 33) throw ERROR_FAIL_TO_DECODE_MNEMONIC; // check that the last byte is actually 0x0\n\n  if (uint8Array[uint8Array.length - 1] !== 0x0) throw ERROR_FAIL_TO_DECODE_MNEMONIC; // chop it !\n\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1); // compute checksum\n\n  const cs = computeChecksum(uint8Array); // success!\n\n  if (cs === checksum) return uint8Array;\n  throw ERROR_FAIL_TO_DECODE_MNEMONIC;\n}\n\nfunction computeChecksum(seed) {\n  const hashBuffer = nacl.genericHash(seed);\n  const uint11Hash = toUint11Array(hashBuffer);\n  const words = applyWords(uint11Hash);\n  return words[0];\n}\n\nfunction applyWords(nums) {\n  return nums.map(n => english[n]);\n} // https://stackoverflow.com/a/51452614\n\n\nfunction toUint11Array(buffer8) {\n  let buffer11 = [];\n  let acc = 0;\n  let accBits = 0;\n\n  function add(octet) {\n    acc = octet << accBits | acc;\n    accBits += 8;\n\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n} // from Uint11Array\n// https://stackoverflow.com/a/51452614\n\n\nfunction toUint8Array(buffer11) {\n  let buffer8 = [];\n  let acc = 0;\n  let accBits = 0;\n\n  function add(ui11) {\n    acc = ui11 << accBits | acc;\n    accBits += 11;\n\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn 25 words Algorand mnemonic\n * @returns {{sk: Uint8Array, addr: string}}\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToSecretKey(mn) {\n  let seed = seedFromMnemonic(mn);\n  let keys = nacl.keyPairFromSeed(seed);\n  let encodedPk = address.encodeAddress(keys.publicKey);\n  return {\n    addr: encodedPk,\n    sk: keys.secretKey\n  };\n}\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction secretKeyToMnemonic(sk) {\n  // get the seed from the sk\n  let seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonicFromSeed(seed);\n}\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToMasterDerivationKey(mn) {\n  return seedFromMnemonic(mn);\n}\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction masterDerivationKeyToMnemonic(mdk) {\n  return mnemonicFromSeed(mdk);\n}\n\nmodule.exports = {\n  mnemonicFromSeed,\n  seedFromMnemonic,\n  ERROR_FAIL_TO_DECODE_MNEMONIC,\n  ERROR_NOT_IN_WORDS_LIST,\n  mnemonicToSecretKey,\n  secretKeyToMnemonic,\n  mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic\n};","map":{"version":3,"sources":["C:/demoAlgo/smart-contracts/devrel/react-dispenser-usdc-algo/dispenser-react-app/node_modules/algosdk/src/mnemonic/mnemonic.js"],"names":["english","require","nacl","address","ERROR_FAIL_TO_DECODE_MNEMONIC","Error","ERROR_NOT_IN_WORDS_LIST","mnemonicFromSeed","seed","length","SEED_BTYES_LENGTH","RangeError","uint11Array","toUint11Array","words","applyWords","checksumWord","computeChecksum","join","seedFromMnemonic","mnemonic","split","key","slice","w","indexOf","checksum","map","word","uint8Array","toUint8Array","cs","hashBuffer","genericHash","uint11Hash","nums","n","buffer8","buffer11","acc","accBits","add","octet","push","flush","forEach","ui11","Uint8Array","mnemonicToSecretKey","mn","keys","keyPairFromSeed","encodedPk","encodeAddress","publicKey","addr","sk","secretKey","secretKeyToMnemonic","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","mdk","module","exports"],"mappings":"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","sourcesContent":["const english = require(\"./wordlists/english\");\nconst nacl = require(\"../nacl/naclWrappers\");\nconst address = require(\"../encoding/address\");\n\nconst ERROR_FAIL_TO_DECODE_MNEMONIC = Error('failed to decode mnemonic');\nconst ERROR_NOT_IN_WORDS_LIST = Error('the mnemonic contains a word that is not in the wordlist');\n\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed 32 bytes long seed\n * @returns {string} 25 words mnemonic\n */\nfunction mnemonicFromSeed(seed) {\n    // Sanity length check\n    if (seed.length !== nacl.SEED_BTYES_LENGTH) {throw new RangeError(\"Seed length must be \" +\n        nacl.SEED_BTYES_LENGTH);}\n\n    const uint11Array = toUint11Array(seed);\n    const words = applyWords(uint11Array);\n    const checksumWord = computeChecksum(seed);\n\n    return words.join(' ') + ' ' + checksumWord;\n}\n\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic 25 words mnemonic\n * @returns {Uint8Array} 32 bytes long seed\n */\nfunction seedFromMnemonic(mnemonic) {\n    const words = mnemonic.split(' ');\n    const key = words.slice(0, 24);\n\n    //Check that all words are in list\n    for (let w of key) {\n        if (english.indexOf(w) === -1) throw ERROR_NOT_IN_WORDS_LIST;\n    }\n\n    const checksum = words[words.length - 1];\n    const uint11Array = key.map(word => english.indexOf(word));\n\n    // Convert the key to uint8Array\n    let uint8Array = toUint8Array(uint11Array);\n\n    // We need to chop the last byte -\n    // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n    // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n    // This left gets padded with another 8 bits to the create the 24th word.\n    // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n\n    // check that we have 33 bytes long array as expected\n    if (uint8Array.length !== 33) throw ERROR_FAIL_TO_DECODE_MNEMONIC;\n\n    // check that the last byte is actually 0x0\n    if (uint8Array[uint8Array.length - 1] !== 0x0) throw ERROR_FAIL_TO_DECODE_MNEMONIC;\n\n    // chop it !\n    uint8Array = uint8Array.slice(0, uint8Array.length - 1);\n\n\n    // compute checksum\n    const cs = computeChecksum(uint8Array);\n\n    // success!\n    if (cs === checksum) return uint8Array;\n\n    throw ERROR_FAIL_TO_DECODE_MNEMONIC;\n}\n\nfunction computeChecksum(seed) {\n    const hashBuffer = nacl.genericHash(seed);\n    const uint11Hash = toUint11Array(hashBuffer);\n    const words = applyWords(uint11Hash);\n\n    return words[0];\n}\n\nfunction applyWords(nums) {\n    return nums.map(n => english[n]);\n}\n\n\n// https://stackoverflow.com/a/51452614\nfunction toUint11Array(buffer8) {\n    let buffer11 = [];\n    let acc = 0;\n    let accBits = 0;\n    function add(octet) {\n        acc = (octet << accBits) | acc;\n        accBits += 8;\n        if (accBits >=11) {\n            buffer11.push( acc & 0x7ff);\n            acc >>= 11;\n            accBits -= 11;\n        }\n    }\n    function flush() {\n        if (accBits) {\n            buffer11.push( acc);\n        }\n    }\n\n    buffer8.forEach( add);\n    flush();\n    return buffer11;\n}\n\n// from Uint11Array\n// https://stackoverflow.com/a/51452614\nfunction toUint8Array(buffer11) {\n    let buffer8 = [];\n    let acc = 0;\n    let accBits = 0;\n    function add(ui11) {\n        acc = (ui11 << accBits) | acc;\n        accBits += 11;\n        while (accBits >= 8) {\n            buffer8.push( acc & 0xff);\n            acc >>= 8;\n            accBits -= 8;\n        }\n    }\n    function flush() {\n        if (accBits) {\n            buffer8.push( acc);\n        }\n    }\n\n    buffer11.forEach( add);\n    flush();\n    return new Uint8Array(buffer8);\n}\n\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn 25 words Algorand mnemonic\n * @returns {{sk: Uint8Array, addr: string}}\n * @throws error if fails to decode the mnemonic\n */\nfunction mnemonicToSecretKey(mn) {\n    let seed = seedFromMnemonic(mn);\n    let keys = nacl.keyPairFromSeed(seed);\n    let encodedPk = address.encodeAddress(keys.publicKey);\n    return {addr: encodedPk, sk: keys.secretKey};\n}\n\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk Uint8Array\n * @returns string mnemonic\n */\nfunction secretKeyToMnemonic(sk) {\n    // get the seed from the sk\n    let seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n    return mnemonicFromSeed(seed);\n}\n\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\nfunction mnemonicToMasterDerivationKey(mn) {\n    return seedFromMnemonic(mn);\n}\n\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk Uint8Array\n * @returns string mnemonic\n */\nfunction masterDerivationKeyToMnemonic(mdk) {\n    return mnemonicFromSeed(mdk);\n}\n\nmodule.exports = {\n    mnemonicFromSeed,\n    seedFromMnemonic,\n    ERROR_FAIL_TO_DECODE_MNEMONIC,\n    ERROR_NOT_IN_WORDS_LIST,\n    mnemonicToSecretKey,\n    secretKeyToMnemonic,\n    mnemonicToMasterDerivationKey,\n    masterDerivationKeyToMnemonic,\n};"]},"metadata":{},"sourceType":"script"}